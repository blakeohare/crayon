
intIntDict1 = new Dictionary<int, int>();
stringIntDict1 = new Dictionary<string, int>();
valueList2 = new List<Value>(); // keys
valueList1 = new List<Value>(); // values

len = row[0];
type = Types.INTEGER;  // always ignored when size is 0
first = true;
i = len; // size
while (i > 0) {
    valueStackSize -= 2;
    value = valueStack[valueStackSize + 1]; // value
    value2 = valueStack[valueStackSize]; // key
    if (first) {
        type = value2.type;
        first = false;
    } else if (type != value2.type) {
        hasInterrupt = EX_InvalidKey(ec, "Dictionary keys must be of the same type.");
    }

    if (!hasInterrupt) {
        if (type == Types.INTEGER) {
            intKey = (int) value2.internalValue;
        } else if (type == Types.STRING) {
            stringKey = (string) value2.internalValue;
        } else if (type == Types.INSTANCE) {
            objInstance1 = (ObjectInstance) value2.internalValue;
            intKey = objInstance1.objectId;
        } else {
            hasInterrupt = EX_InvalidKey(ec, "Only integers, strings, and objects can be used as dictionary keys.");
        }
    }

    if (!hasInterrupt) {
        if (type == Types.STRING) {
            stringIntDict1[stringKey] = valueList1.Size();
        } else {
            intIntDict1[intKey] = valueList1.Size();
        }
        valueList2.Add(value2);
        valueList1.Add(value);
        i -= 1;
    }
}

if (!hasInterrupt) {
    if (type == Types.STRING) {
        i = stringIntDict1.Size();
    } else {
        i = intIntDict1.Size();
    }
    if (i != len) {
        hasInterrupt = EX_InvalidKey(ec, "Key collision"); // TODO: do a better job of figuring out where this collision is.
    }
}

if (!hasInterrupt) {
    @import("ValueStackCapacityCheck.pst");
    valueStack[valueStackSize] = new Value(Types.DICTIONARY, new DictImpl(
        len,
        type,
        intIntDict1,
        stringIntDict1,
        valueList2,
        valueList1));
    valueStackSize += 1;
}

value = ec.activeException;
if ((value == null) || ec.activeExceptionHandled) {
	switch (stack.postFinallyBehavior) {
		case PostFinallyBehavior.NOTHING:
			ec.activeException = null;
			break;
		case PostFinallyBehavior.BREAK:
			ec.activeException = null;
			int1 = row[0];
			if (int1 == 1) {
				pc += row[1];
			} else {
				if (int1 == 2) {
					intArray1 = esfData[pc];
					pc = intArray1[1];
				} else {
					return Core.GenerateException(CoreExceptionTypes.FATAL, "break exists without a loop");
				}
			}
			break;
		case PostFinallyBehavior.CONTINUE:
			ec.activeException = null;
			int1 = row[2];
			if (int1 == 1) {
				pc += row[3];
			} else {
				if (int1 == 2) {
					intArray1 = esfData[pc];
					pc = intArray1[1];
				} else {
					return Core.GenerateException(CoreExceptionTypes.FATAL, "continue exists without a loop");
				}
			}
			break;
		case PostFinallyBehavior.RETURN:
			if (stack.markClassAsInitialized != 0) {
				markClassAsInitialized(stack, stack.markClassAsInitialized);
			}
			if (stack.returnValueUsed) {
				valueStackSize = stack.valueStackPopSize;
				value = stack.returnValueTempStorage;
				stack = stack.previous;
				@import("ValueStackCapacityCheck.cry");
				valueStack[valueStackSize] = value;
				valueStackSize += 1;
			} else {
				valueStackSize = stack.valueStackPopSize;
				stack = stack.previous;
			}
			pc = stack.pc;
			localsStackOffset = stack.localsStackOffset;
			localsStackSetToken = stack.localsStackSetToken;
			break;
	}
} else {
	@import("BubbleException.cry");
}

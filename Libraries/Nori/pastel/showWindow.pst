/*
    args[0] -> (ObjectInstance) window native instance
    args[1] -> (List<Value>) properties
*/
VM.Value lib_nori_showWindow(VM.VmContext vm, Array<VM.Value> args) {
    VM.ObjectInstance window = (VM.ObjectInstance) args[0].internalValue;
    VM.ListImpl properties = (VM.ListImpl) args[1].internalValue;
    VM.ObjectInstance root = (VM.ObjectInstance) args[2].internalValue;
    // TODO: conditionally execute this code.
    // The only reason the properties are required here is if a platform doesn't allow changing these properties without a window being shown on the screen.
    // Alternatively, if there are no platforms like that or I can work around this, then remove the property stuff outright.
    int propertyCount = properties.size;
    Array<object> unboxedValues = new Array<object>(propertyCount);
    for (int i = 0; i < propertyCount; i += 1) {
        unboxedValues[i] = VM.getItemFromList(properties, i).internalValue;
    }

    int execId = VM.vm_getCurrentExecutionContextId(vm);

    Extension._lib_nori_showWindow(window.nativeData[0], unboxedValues, root.nativeData[0], execId);

    // If this is JavaScript, this will run immediately after the showWindow call. Therefore the VM
    // must be suspended. The JavaScript implementation of Nori will fire a new Interpreter process once
    // the closed handler is run.
    if (!@ext_boolean("IS_WINDOW_SHOW_BlOCKING")) {
        VM.vm_suspend_with_status(vm, 1);
    }

    return vm.globalNull;
}

C$common = 1;
C$common$textResources = {};
C$common$jsFilePrefix = ''; // overridden by resources.js if present.
C$common$programData = null;
C$common$resources = {};
C$common$binaryResources = {};
C$common$libraryFunctionLookups = {};

C$common$globalOptions = {};
C$common$globalOptions['fullscreen'] = false;

function main() {
	C$common$programData = createVm(C$bytecode, C$common$resourceManifest);
	C$handleVmResult(startVm(C$common$programData));
}

function C$runInterpreter(execId) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreter(vm, execId));
}

function C$runInterpreterWithFunctionPointer(fp, args) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreterWithFunctionPointer(vm, fp, args));
}

function C$handleVmResult(res) {
	var vm = C$common$programData;
	var status = getVmResultStatus(res);
	while (status == 5 || status == 6) { // REINVOKE || LOAD_ASSEMBLY
		if (status == 5) {
			var delayMillis = Math.floor(1000 * getVmReinvokeDelay(res));
			var execId = getVmResultExecId(res);
			window.setTimeout(function() { C$runInterpreter(execId); }, delayMillis);
			return;
		} else {
			var parts = getVmResultAssemblyInfo(res).split(',');
			var name = parts[0];
			var version = parts[1];
			var startupFunc = parts[2];
			C$loadAssembly(name, version, startupFunc);
		}
		res = runInterpreter(vm, getVmResultExecId(res))
		status = getVmResultStatus(res);
	}

	if (status == 1 || status == 2 || status == 3) return;

	throw "Unknown status";
}

C$loadAssembly = function(name, ver, startupFn) {
	if (startupFn.length > 0) {
		var fn = window[startupFn];
		if (fn !== undefined) {
			fn(C$common$programData, []);
		}
	}
};

C$common$readResourceText = function (path) {
	var v = C$common$getTextRes(path);
	return !v ? null : v;
};

C$common$alwaysTrue = function () { return true; };
C$common$alwaysFalse = function () { return false; };

C$common$addTextRes = function (path, value) {
	C$common$textResources[path] = value;
};

C$common$getTextRes = function (path) {
	return C$common$textResources[path];
};

C$common$addBinaryRes = function (path, value) {
	C$common$binaryResources[path] = value;
};

C$common$getBinaryResBase64 = function (path) {
	return C$common$binaryResources[path];
};

C$common$print = function (value) {
	console.log(value);
};

C$common$scrapeLibFuncNames = function(libname) {
	var prefix = 'lib_' + libname + '_function_';
	var functions = {};
	for (var key in window) {
		if (key.indexOf(prefix) === 0) {
			var name = key.substring(prefix.length, key.length + prefix.length);
			functions[name] = window[key];
		}
	}
	C$common$libraryFunctionLookups[libname] = functions;
};

C$common$getFunction = function(name) {
	var p = name.split(',');
	var check = p[p.length - 1];
	if (window[check] !== undefined) {
		return window[check];
	}
	return null;
};

LIB$datetime$utcTimeZone = {
	name: "utc",
	isLocal: false,
	observesDst: false
};

LIB$datetime$extractTimeZone = function(nullableTz) {
	if (nullableTz === null) return LIB$datetime$utcTimeZone;
	return nullableTz;
};

LIB$datetime$getDataForLocalTimeZone = function(strOut, intOut) {
	var name = Intl.DateTimeFormat().resolvedOptions().timeZone;
	strOut[0] = name;
	strOut[1] = name;
	intOut[0] = -1; // TODO: remove this
	var now = new Date();
	var janSeconds = new Date(now.getFullYear(), 1, 1, 0, 0, 0).getTime() / 1000;
	var junSeconds = new Date(now.getFullYear(), 6, 1, 0, 0, 0).getTime() / 1000;
	var janToJunHours = (junSeconds - janSeconds) / 3600;
	var dstOccurs = (janToJunHours % 24) != 0;
	intOut[1] = dstOccurs ? 1 : 0;
	return {
		name: name,
		isLocal: true,
		observesDst: dstOccurs
	};
};

LIB$datetime$unixToStructured = function(intOut, nullableTimeZone, unixTime) {
	var unixTimeInt = Math.floor(unixTime);
	var micros = Math.floor(1000000 * (unixTime - unixTimeInt));
	var millis = Math.floor(micros / 1000);
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	var d = new Date(Math.floor(unixTime * 1000));
	intOut[6] = millis;
	intOut[7] = micros;
	if (tz.isLocal) {
		intOut[0] = d.getFullYear();
		intOut[1] = d.getMonth() + 1;
		intOut[2] = d.getDate();
		intOut[3] = d.getHours();
		intOut[4] = d.getMinutes();
		intOut[5] = d.getSeconds();
		intOut[8] = d.getDay() + 1;
	} else {
		var p = d.toISOString().split('Z')[0].split('T');
		var pd = p[0].split('-');
		var pt = p[1].split('.')[0].split(':');
		
		intOut[0] = parseInt(pd[0]);
		intOut[1] = parseInt(pd[1]);
		intOut[2] = parseInt(pd[2]);
		intOut[3] = parseInt(pt[0]);
		intOut[4] = parseInt(pt[1]);
		intOut[5] = parseInt(pt[2]);
		intOut[8] = new Date(intOut[0], intOut[1] - 1, intOut[2], 12, 0, 0).getDay() + 1;
	}
	return true;
};

LIB$datetime$pad = function(n, length) {
	n = n + '';
	while (n.length < length) {
		n = '0' + n;
	}
	return n;
};
LIB$datetime$parseDate = function(intOut, nullableTimeZone, year, month, day, hour, minute, microseconds) {
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	intOut[2] = microseconds % 1000000;
	intOut[0] = 1;
	var seconds = Math.floor((microseconds - intOut[2]) / 1000000);
	if (tz.isLocal) {
		var d = new Date(year, month - 1, day, hour, minute, seconds);
		intOut[1] = Math.floor(d.getTime() / 1000);
	} else {
		intOut[1] = new Date([
			year, "-",
			LIB$datetime$pad(month, 2), "-",
			LIB$datetime$pad(day, 2), "T",
			LIB$datetime$pad(hour, 2), ":",
			LIB$datetime$pad(minute, 2), ":",
			LIB$datetime$pad(seconds, 2), "Z"].join('')).getTime();
	}
};

LIB$datetime$getUtcOffsetAt = function(tz, unixTime) {
	var d = new Date(Math.floor(unixTime * 1000));
	return -60 * d.getTimezoneOffset();
};

valueStackSize -= 2;
rightValue = valueStack[(valueStackSize + 1)];
leftValue = valueStack[valueStackSize];
leftType = leftValue.type;
rightType = rightValue.type;
op = row[0];
value = null;
if (Core.ForceParens((leftType == Types.STRING) || (rightType == Types.STRING)) && (op == BinaryOps.ADDITION) && (leftType != Types.NULL) && (rightType != Types.NULL)) {
    value = new Value(Types.STRING, Core.StringConcatAll(valueToString(leftValue), valueToString(rightValue)));
} else {
    left = leftValue.internalValue;
    right = rightValue.internalValue;
    switch (((((leftValue.type * MAX_OP) + op) * MAX_TYPE) + rightValue.type)) {
        case (((Types.INTEGER * MAX_OP) + BinaryOps.EXPONENT) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int ** int");
            if (((int) right) == 0) {
                value = VALUE_INT_ONE;
            } else {
                if (((int) right) > 0) {
                    value = buildInteger(Core.Int(Core.Pow(((int) left), ((int) right))));
                } else {
                    value = buildFloat(Core.Pow(((int) left), ((int) right)));
                }
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.EXPONENT) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int ** float");
            value = buildFloat(0.0 + Core.Pow(((int) left), ((double) right)));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.EXPONENT) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float ** int");
            value = buildFloat(0.0 + Core.Pow(((double) left), ((int) right)));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.EXPONENT) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float ** float");
            value = buildFloat(0.0 + Core.Pow(((double) left), ((double) right)));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.MODULO) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float % float");
            if (((double) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Modulo by 0.");
            }
            float3 = ((double) left) % ((double) right);
            if (float3 < 0) {
                float3 += ((double) right);
            }
            value = buildFloat(float3);
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.MODULO) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float % int");
            if (((int) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Modulo by 0.");
            }
            float1 = ((double) left) % ((int) right);
            if (float1 < 0) {
                float1 += ((int) right);
            }
            value = buildFloat(float1);
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MODULO) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int % float");
            if (((double) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Modulo by 0.");
            }
            float1 = ((int) left) % ((double) right);
            if (float1 < 0) {
                float1 += ((double) right);
            }
            value = buildFloat(float1);
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MODULO) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int % int");
            if (((int) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Modulo by 0.");
            }
            int1 = ((int) left) % ((int) right);
            if (int1 < 0) {
                int1 += ((int) right);
            }
            value = buildInteger(int1);
            break;
        case (((Types.LIST * MAX_OP) + BinaryOps.ADDITION) * MAX_TYPE) + Types.LIST:
            Core.EmitComment("list + list");
            value = new Value(Types.LIST, Core.ListConcat(((List<Value>) left), ((List<Value>) right)));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.ADDITION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int + int");
            int1 = ((int) left) + ((int) right);
            if (int1 < 0) {
                if (int1 > -INTEGER_NEGATIVE_CACHE_SIZE) {
                    value = INTEGER_NEGATIVE_CACHE[-int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            } else {
                if (int1 < INTEGER_POSITIVE_CACHE_SIZE) {
                    value = INTEGER_POSITIVE_CACHE[int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.SUBTRACTION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int - int");
            int1 = ((int) left) - ((int) right);
            if (int1 < 0) {
                if (int1 > -INTEGER_NEGATIVE_CACHE_SIZE) {
                    value = INTEGER_NEGATIVE_CACHE[-int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            } else {
                if (int1 < INTEGER_POSITIVE_CACHE_SIZE) {
                    value = INTEGER_POSITIVE_CACHE[int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int * int");
            int1 = ((int) left) * ((int) right);
            if (int1 < 0) {
                if (int1 > -INTEGER_NEGATIVE_CACHE_SIZE) {
                    value = INTEGER_NEGATIVE_CACHE[-int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            } else {
                if (int1 < INTEGER_POSITIVE_CACHE_SIZE) {
                    value = INTEGER_POSITIVE_CACHE[int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.DIVISION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int / int");
            if (((int) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Division by 0.");
            }
            int1 = Core.IntegerDivision(((int) left), ((int) right));
            if (int1 < 0) {
                if (int1 > -INTEGER_NEGATIVE_CACHE_SIZE) {
                    value = INTEGER_NEGATIVE_CACHE[-int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            } else {
                if (int1 < INTEGER_POSITIVE_CACHE_SIZE) {
                    value = INTEGER_POSITIVE_CACHE[int1];
                } else {
                    value = new Value(Types.INTEGER, int1);
                }
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.ADDITION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float + int");
            value = buildFloat(((double) left) + ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.ADDITION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int + float");
            value = buildFloat(((int) left) + ((double) right));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.ADDITION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float + float");
            value = buildFloat(((double) left) + ((double) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.SUBTRACTION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int - float");
            value = buildFloat(((int) left) - ((double) right));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.SUBTRACTION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float - int");
            value = buildFloat(((double) left) - ((int) right));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.SUBTRACTION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float - float");
            value = buildFloat(((double) left) - ((double) right));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float * int");
            value = buildFloat(((double) left) * ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int * float");
            value = buildFloat(((int) left) * ((double) right));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float * float");
            value = buildFloat(((double) left) * ((double) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.DIVISION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int / float");
            if (((double) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Division by 0.");
            }
            value = buildFloat(Core.FloatDivision(((int) left), ((double) right)));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.DIVISION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float / int");
            if (((int) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Division by 0.");
            }
            value = buildFloat(Core.FloatDivision(((double) left), ((int) right)));
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.DIVISION) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float / float");
            if (((double) right) == 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.DIVISION_BY_ZERO, "Division by 0.");
            }
            value = buildFloat(Core.FloatDivision(((double) left), ((double) right)));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.BITWISE_AND) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int & int");
            value = buildInteger(((int) left) & ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.BITWISE_OR) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int & int");
            value = buildInteger(((int) left) | ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.BITWISE_XOR) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int & int");
            value = buildInteger(((int) left) ^ ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.BIT_SHIFT_LEFT) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int << int");
            int1 = ((int) right);
            if (int1 < 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.INVALID_ARGUMENT, "Cannot bit shift by a negative number.");
            }
            value = buildInteger(((int) left) << int1);
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.BIT_SHIFT_RIGHT) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int >> int");
            int1 = ((int) right);
            if (int1 < 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.INVALID_ARGUMENT, "Cannot bit shift by a negative number.");
            }
            value = buildInteger(((int) left) >> int1);
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.LESS_THAN) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int < int");
            if (((int) left) < ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int <= int");
            if (((int) left) <= ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.LESS_THAN) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float < int");
            if (((double) left) < ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float <= int");
            if (((double) left) <= ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.LESS_THAN) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int < float");
            if (((int) left) < ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int <= float");
            if (((int) left) <= ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.LESS_THAN) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float < float");
            if (((double) left) < ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.LESS_THAN_OR_EQUAL) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float <= float");
            if (((double) left) <= ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int >= int");
            if (((int) left) >= ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.GREATER_THAN) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("int > int");
            if (((int) left) > ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float >= int");
            if (((double) left) >= ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.GREATER_THAN) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("float > int");
            if (((double) left) > ((int) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int >= float");
            if (((int) left) >= ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.GREATER_THAN) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("int > float");
            if (((int) left) > ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.GREATER_THAN_OR_EQUAL) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float >= float");
            if (((double) left) >= ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.FLOAT * MAX_OP) + BinaryOps.GREATER_THAN) * MAX_TYPE) + Types.FLOAT:
            Core.EmitComment("float > float");
            if (((double) left) > ((double) right)) {
                value = VALUE_TRUE;
            } else {
                value = VALUE_FALSE;
            }
            break;
        case (((Types.STRING * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("string * int");
            value = multiplyString(leftValue, ((string) left), ((int) right));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.STRING:
            Core.EmitComment("int * string");
            value = multiplyString(rightValue, ((string) right), ((int) left));
            break;
        case (((Types.LIST * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.INTEGER:
            Core.EmitComment("list * int");
            int1 = ((int) right);
            if (int1 < 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.UNSUPPORTED_OPERATION, "Cannot multiply list by negative number.");
            }
            value = new Value(Types.LIST, Core.MultiplyList(((List<Value>) left), int1));
            break;
        case (((Types.INTEGER * MAX_OP) + BinaryOps.MULTIPLICATION) * MAX_TYPE) + Types.LIST:
            Core.EmitComment("int * list");
            int1 = ((int) left);
            if (int1 < 0) {
                return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.UNSUPPORTED_OPERATION, "Cannot multiply list by negative number.");
            }
            value = new Value(Types.LIST, Core.MultiplyList(((List<Value>) right), int1));
            break;
        default:
            Core.EmitComment("unrecognized op");
            return generateException(stack, pc, valueStackSize, ec, CoreExceptionTypes.UNSUPPORTED_OPERATION, Core.StringConcatAll("The '", getBinaryOpFromId(row[0]), "' operator is not supported for these types: ", getTypeFromId(leftValue.type), " and ", getTypeFromId(rightValue.type)));
    }
}
@import("ValueStackCapacityCheck.cry");
valueStack[valueStackSize] = value;
valueStackSize += 1;

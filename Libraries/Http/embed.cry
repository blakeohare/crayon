namespace Http {

    const DEFAULT_USER_AGENT = "Crayon/v" + Core.CRAYON_VERSION + "; Have a nice day.";

    enum Method {
        GET = 1,
        POST = 2,
        PUT = 3,
        DELETE = 4,
    }

    enum StatusCode {
        CONTINUE = 100,
        SWITCHING_PROTOCOLS = 101,
        PROCESSING = 102,
        CHECKPOINT = 103,

        OK = 200,
        CREATED = 201,
        ACCEPTED = 202,
        NON_AUTHORITATIVE_INFORMATION = 203,
        NO_CONTENT = 204,
        RESET_CONTENT = 205,
        PARTIAL_CONTENT = 206,
        MULTI_STATUS = 207,
        ALREADY_REPORTED = 208,
        IM_USED = 226,

        MULTIPLE_CHOICES = 300,
        MOVED_PERMANENTLY = 301,
        MOVED_TEMPORARILY = 302,
        SEE_OTHER = 303,
        NOT_MODIFIED = 304,
        USE_PROXY = 305,
        SWITCH_PROXY = 306,
        TEMPORARY_REDIRECT = 307,
        PERMANENT_REDIRECT = 308,

        BAD_REQUEST = 400,
        UNAUTHORIZED = 401,
        PAYMENT_REQUIRED = 402,
        FORBIDDEN = 403,
        NOT_FOUND = 404,
        METHOD_NOT_ALLOWED = 405,
        NOT_ACCEPTABLE = 406,
        PROXY_AUTHENTICATION_REQUIRED = 407,
        REQUEST_TIMEOUT = 408,
        CONFLICT = 409,
        GONE = 410,
        LENGTH_REQUIRED = 411,
        PRECONDITION_FAILED = 412,
        PAYLOAD_TOO_LARGE = 413,
        URI_TOO_LONG = 414,
        UNSUPPORTED_MEDIA_TYPE = 415,
        RANGE_NOT_SATISFIABLE = 416,
        EXPECTATION_FAILED = 417,
        IM_A_TEAPOT = 418,
        ENHANCE_YOUR_CALM = 420,
        MISDIRECTED_REQUEST = 421,
        UNPROCESSABLE_ENTITY = 422,
        LOCKED = 423,
        FAILED_DEPENDENCY = 424,
        UPGRADE_REQUIRED = 426,
        PRECONDITION_REQUIRED = 428,
        TOO_MANY_REQUESTS = 429,
        REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
        LOGIN_TIMEOUT = 440,
        RETRY_WITH = 449,
        BLOCKED_BY_PARENTAL_CONTROLS = 450,
        UNAVAILABLE_FOR_LEGAL_REASONS = 451,

        INTERNAL_SERVER_ERROR = 500,
        NOT_IMPLEMENTED = 501,
        BAD_GATEWAY = 502,
        SERVICE_UNAVAILABLE = 503,
        GATEWAY_TIMEOUT = 504,
        HTTP_VERSION_NOT_SUPPORTED = 505,
        VARIANT_ALSO_NEGOTIATES = 506,
        INSUFFICIENT_STORAGE = 507,
        LOOP_DETECTED = 508,
        BANDWIDTH_LIMIT_EXCEEDED = 509,
        NOT_EXTENDED = 510,
        NETWORK_AUTHENTICATION_REQIURED = 511,
    }

    class HttpResponse {
        /*
            nativeData[0] -> a byte array if this is a binary response
        */
        field _headerValues = {}; // key is lowercase
        field _headerNames = []; // original case
        field _content;
        field _statusCode = 0;
        field _statusMessage = '';
        field _isBinary = false;

        @private constructor() { }

        static function _initialize(request) {
            response = new HttpResponse();
            output = [];
            headersOut = [];
            $$lib_http_populateResponse(request, response, output, headersOut);
            for (i = 0; i < headersOut.length; i += 2) {
                name = headersOut[i].trim();
                key = name.lower();
                value = headersOut[i + 1];
                values = response._headerValues.get(key);
                if (values == null) {
                    values = [];
                    response._headerValues[key] = values;
                    response._headerNames.add(name);
                }
                values.add(value);
            }
            response._statusCode = output[0];
            response._statusMessage = output[1];
            response._content = output[2];
            response._isBinary = output[3];

            return response;
        }

        function getHeaderNames() {
            return this._headerNames;
        }

        function getHeaders(name) {
            output = this._headerNames.get(name.loweer());
            if (output == null) return [];
            return output.clone();
        }

        function getHeader(name) {
            output = this._headerNames.get(name.lower());
            if (output == null) return null;
            return output[0];
        }

        function getContent() {
            if (this._isBinary) {
                output = [];
                // just returns output
                return $$lib_http_getResponseBytes(this, output);
            }
            return this._content;
        }

        function getStatusCode() {
            return this._statusCode;
        }

        function getStatusMessage() {
            return this._statusMessage;
        }
    }

    enum RequestMode {
        TEXT = 0,
        BINARY = 1,
    }

    class HttpRequest {

        /*
            nativeData[0] -> a reference to an ongoing HTTP request object
            nativeData[1] -> if applicable, a mutex for accessing the asynchronous HTTP request
            nativeData[2] -> boolean: is done
        */
        static field _active_requests = null;

        field _url;
        field _method = Http.Method.GET;
        field _headers = [];
        field _content = null;
        field _mode = Http.RequestMode.TEXT;
        field _isReady = false;
        field _contentIsBinary = false;
        field _userAgent = Http.DEFAULT_USER_AGENT;
        field _contentType = null;
        field _timesPolled = 0;

        constructor(url) {
            this._url = url + '';
        }

        function setMethod(method) {
            this._method = method;
            return this;
        }

        function setHeader(name, value) {
            Core.assert(Core.typeof(name) == Core.Type.STRING, "HTTP header name must be a string.");
            name = name.trim();
            Core.assert(name.length > 0, "HTTP header name must be non-empty.");
            Core.assert(value != null, "HTTP header value cannot be null.");

            value = value + '';
            switch (name.lower()) {
                case 'user-agent': this._userAgent = value; break;
                case 'content-type': this._contentType = value; break;
                default: this._headers.add(name, value); break;
            }
            return this;
        }

        function setContentBytes(value, contentType = null) {
            obj = new Object();
            if (!$$lib_http_fastEnsureAllBytes(value, obj)) Core.fail("Input must be a list of byte values");

            this._content = obj;
            this._contentIsBinary = true;
            return this._setContentHelper(contentType);
        }

        function setContent(value, contentType = null) {
            this._content = value + '';
            this._contentIsBinary = false;
            return this._setContentHelper(contentType);
        }

        function _setContentHelper(contentType) {
            if (contentType != null) {
                this.setHeader('Content-Type', contentType);
            }
            if (this._method == null) {
                this._method = Http.Method.POST;
            }
            return this;
        }

        function setMode(mode) {
            this._mode = mode;
            return this;
        }

        function send() {
            this._sendImpl(false);
            this._isReady = true;
            return this.getResponse();
        }

        function sendAsync() {
            return this._sendImpl(true);
        }

        function _sendImpl(isAsync) {

            method = {
                Http.Method.GET: 'GET',
                Http.Method.POST: 'POST',
                Http.Method.PUT: 'PUT',
                Http.Method.DELETE: 'DELETE',
            }.get(this._method, this._method) + '';

            this._headers.add('User-Agent', this._userAgent);
            if (this._contentType != null) {
                this._headers.add('Content-Type', this._contentType);
            }

            $$lib_http_sendRequest(
                this,
                isAsync,
                method,
                this._url,
                this._headers,
                this._content,
                this._mode);
            return this;
        }

        function isDone() {
            if (this._isReady) return true;

            if (this._timesPolled++ > 10) {
                this._timesPolled = 0;
                // Yield the thread for a tiny moment to give the handler a chance to run for platforms that require
                // asynchronous HTTP requests to invoke a completion handler on the main thread.
                Core.sleep(0.001);
            }

            if ($$lib_http_pollRequest(this)) { // updates the native data
                this._isReady = true;
            }

            return this._isReady;
        }

        function getResponse() {
            Core.assert(this._isReady, "Request not finished.");
            return Http.HttpResponse._initialize(this);
        }
    }
}

VmContext createVm(string rawByteCode, string resourceManifest) {

    VmGlobals globals = initializeConstantValues();
    ResourceDB resources = resourceManagerInitialize(globals, resourceManifest);
    Code byteCode = initializeByteCode(rawByteCode);

    Array<Value> localsStack = new Array<Value>(10);
    Array<int> localsStackSet = new Array<int>(10);
    int i = 0;
    for (i = localsStack.Size() - 1; i >= 0; i -= 1) {
        localsStack[i] = null;
        localsStackSet[i] = 0;
    }

    StackFrame stack = new StackFrame(
        0, // pc
        1, // localsStackSetToken
        0, // localsStackOffset
        0, // localsStackOffsetEnd
        null, // previous
        false, // returnValueUsed
        null, // object context
        0, // valueStackSize
        0, // static initialization class ID marker upon completion (not applicable here)
        1, // stack depth
        PostFinallyBehavior.NOTHING,
        null, // temp return value
        null, // closure lookup
        null);

    ExecutionContext executionContext = new ExecutionContext(
        0, // execution context ID. 0 is always the root process and execution will end entirely if this context ends.
        stack,

        // The value stack:
        0, // size
        100, // capacity
        new Array<Value>(100), // array

        localsStack,
        localsStackSet,
        1, // localsStackSetToken

        0, // executionCounter

        false, // exception handled
        null, // active exception

        false, // execution state changed
        0, // execution state change command

        null); // active interrupt

    Dictionary<int, ExecutionContext> executionContexts = new Dictionary<int, ExecutionContext>();
    executionContexts[0] = executionContext;

    VmContext vm = new VmContext(
        executionContexts,
        executionContext.id, // last execution context ID
        byteCode,
        new SymbolData(
            new Array<List<Token>>(byteCode.ops.Size()), // token data
            null, // original source code data
            new List<string>(), // original source code data builder
            null, // file names by ID
            null, // file ID's by name

            // local variable and closure names
            new Dictionary<int, List<string>>(),
            new Dictionary<int, List<string>>()),

        new VmMetadata(
            null, // identifiers
            new List<string>(), // identifiers builder
            new Dictionary<string, int>(), // invIdentifiers
            null, // literal table
            new List<Value>(), // literal table builder
            null, // integer switch lookups
            new List<Dictionary<int, int>>(), // integer switch lookups builder
            null, // string switch lookups
            new List<Dictionary<string, int>>(), // string switch lookups builder
            new Array<ClassInfo>(100),
            new Array<FunctionInfo>(100),
            new Dictionary<int, FunctionInfo>(),
            null, // globalNameIdToPrimitiveMethodName (set in FINALIZE_INITIALIZATION)
            new Dictionary<int, Func<Value, VmContext, Array<Value>>>(), // CNI function pointers by ID
            -1, // the global name ID for "length"
            new Array<int>(10), // primitive method to function ID fallback lookup
            0, // user code start
            null, // project ID (set during finalize initialization)
            null, // ESF data (generated by the ESF_LOOKUP op)
            new MagicNumbers(0, 0, 0),

            new Dictionary<string, int>(), // inverse function name literal lookup
            new Dictionary<int, Dictionary<int, int>>(), // classMemberLocalizerBuilder

            null // most recently defined function
        ),
        0, // instance counter

        false, // initialization complete

        new List<int>(), // class static initialization stack
        null, // funcArgs (set in FINALIZE_INITIALIZATION)

        resources, // resource database

        new List<Value>(), // shutdown handlers
        new VmEnvironment(new Array<string>(0), false, null, null), // VM Environment with default values.

        // Globals
        globals,
        globals.valueNull,
        globals.boolTrue,
        globals.boolFalse
        );
    return vm;
}

InterpreterResult startVm(VmContext vm) {
    return runInterpreter(vm, vm.lastExecutionContextId);
}

/*
    Returns a boolean. If false, end the program entirely.

    It is conceivable that the initial invocation to this will block and create successive invocations
    during the lifetime of the initial invocation. (for example, a blocking window is opened)
    This is why the output of the initial invocation is meaningless.
*/
InterpreterResult runInterpreter(VmContext vm, int executionContextId) {
    InterpreterResult result = interpret(vm, executionContextId);
    result.executionContextId = executionContextId; // I feel like this should be set internally.
    int status = result.status;
    if (status == InterpreterResultStatus.FINISHED) {
        if (vm.executionContexts.Contains(executionContextId)) {
            vm.executionContexts.Remove(executionContextId);
        }
        runShutdownHandlers(vm);
    } else if (status == InterpreterResultStatus.FATAL_ERROR) {
        // TODO: don't generate the error in the interpreter. Instead just return the message and
        // the stack trace will be determined from the stack here. Also later add logic to
        // conditionally find symbol information here.
        printToStdOut(vm.environment.stacktracePrefix, result.errorMessage);
        runShutdownHandlers(vm);
    }
    if (executionContextId == 0) {
        result.isRootContext = true;
    }
    return result;
}

int runShutdownHandlers(VmContext vm) {
    // This will recursively invoke the shutdown handlers upon completion,
    // so be sure to pop off the handler as it's used.
    while (vm.shutdownHandlers.Size() > 0) {
        // Pop from the front. An iterating index will not be accurate if state is modified recursively.
        Value handler = vm.shutdownHandlers[0];
        vm.shutdownHandlers.RemoveAt(0);
        runInterpreterWithFunctionPointer(vm, handler, new Array<Value>(0));
    }
    return 0;
}

InterpreterResult runInterpreterWithFunctionPointer(VmContext vm, Value fpValue, Array<Value> args) {
    int newId = vm.lastExecutionContextId + 1;
    vm.lastExecutionContextId = newId;
    List<Value> argList = new List<Value>();
    for (int i = 0; i < args.Size(); i += 1) {
        argList.Add(args[i]);
    }
    Array<Value> locals = new Array<Value>(0);
    Array<int> localsSet = new Array<int>(0);
    Array<Value> valueStack = new Array<Value>(100);
    valueStack[0] = fpValue;
    valueStack[1] = new Value(Types.LIST, argList);
    StackFrame stack = new StackFrame(
        vm.byteCode.ops.Size() - 2, // pc
        1, // localsStackSetToken
        0, // localsStackOffset
        0, // localsStackOffsetEnd
        null, // previous
        false, // returnValueUsed
        null, // object context
        0, // valueStackSize
        0, // static initialization class ID marker upon completion (not applicable here)
        1, // stack depth
        PostFinallyBehavior.NOTHING,
        null, // temp return value
        null, // closure lookup
        null); // debug step tracker

    ExecutionContext executionContext = new ExecutionContext(
        newId, // execution context ID. 0 is always the root process and execution will end entirely if this context ends.
        stack,

        // The value stack:
        2, // size
        100, // capacity
        valueStack, // array

        locals,
        localsSet,
        1, // localsStackSetToken

        0, // executionContext

        false, // exception handled
        null, // active exception

        false, // execution state changed
        0, // execution state change command

        null); // active interrupt

    vm.executionContexts[newId] = executionContext;
    return runInterpreter(vm, newId);
}

// TODO: remove this (usages may still exist in some libraries as artifacts of .cry->.pst conversion)
int noop() {
    return 0;
}

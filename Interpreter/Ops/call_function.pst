type = row[0];
argCount = row[1];
functionId = row[2];
returnValueUsed = row[3] == 1;
classId = row[4];
bool1 = true;
if ((type == FunctionInvocationType.STATIC_METHOD) || (type == FunctionInvocationType.CONSTRUCTOR)) {
	Core.EmitComment("constructor or static method");
	classInfo = p.classTable[classId];
	@import("InvokeStaticConstructor.cry");
}
if (bool1) {
	Core.EmitComment("construct args array");
	if (argCount == -1) {
		valueStackSize -= 1;
		value = valueStack[valueStackSize];
		if (value.type == Types.NULL) {
			argCount = 0;
		} else {
			if (value.type == Types.LIST) {
				list1 = ((List<Value>) value.internalValue);
				argCount = list1.Length;
				for (i = argCount - 1; i >= 0; i -= 1) {
					funcArgs[i] = list1[i];
				}
			} else {
				return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, "Function pointers' .invoke method requires a list argument.");
			}
		}
	} else {
		for (i = argCount - 1; i >= 0; i -= 1) {
			valueStackSize -= 1;
			funcArgs[i] = valueStack[valueStackSize];
		}
	}
	if (type == FunctionInvocationType.LOCAL_METHOD) {
		value = stack.objectContext;
		objInstance1 = ((ObjectInstance) value.internalValue);
		if (objInstance1.classId != classId) {
			int2 = row[5];
			if (int2 != -1) {
				classInfo = classTable[objInstance1.classId];
				functionId = classInfo.functionIds[int2];
			}
		}
	} else {
		if (type == FunctionInvocationType.FIELD_INVOCATION) {
			Core.EmitComment("field invocation");
			valueStackSize -= 1;
			value = valueStack[valueStackSize];
			switch (value.type) {
				case Types.NULL:
					return Core.GenerateException(CoreExceptionTypes.NULL_REFERENCE, "Invoked method on null.");
				case Types.INSTANCE:
					Core.EmitComment("field invoked on an object instance.");
					objInstance1 = ((ObjectInstance) value.internalValue);
					int1 = objInstance1.classId;
					classInfo = classTable[int1];
					if (classInfo.globalIdToMemberId.Contains(classId)) {
						int1 = classInfo.globalIdToMemberId[classId];
						functionId = classInfo.functionIds[int1];
						if (functionId > 0) {
							type = FunctionInvocationType.LOCAL_METHOD;
						} else {
							value = objInstance1.members[int1];
							type = FunctionInvocationType.POINTER_PROVIDED;
							valueStack[valueStackSize] = value;
							valueStackSize += 1;
						}
					} else {
						return Core.GenerateException(CoreExceptionTypes.UNKNOWN_FIELD, "Unknown field.");
					}
					break;
				case Types.CLASS:
					Core.EmitComment("field invocation on a class object instance.");
					functionId = resolvePrimitiveMethodName2(globalNameIdToPrimitiveMethodName, value.type, classId);
					if (functionId < 0) {
						return Core.GenerateException(CoreExceptionTypes.INVALID_INVOCATION, "Class definitions do not have that method.");
					}
					functionId = resolvePrimitiveMethodName2(globalNameIdToPrimitiveMethodName, value.type, classId);
					if (functionId < 0) {
						return Core.GenerateException(CoreExceptionTypes.INVALID_INVOCATION, Core.StringConcatAll(getTypeFromId(value.type), " does not have that method."));
					}
					if (globalNameIdToPrimitiveMethodName[classId] == PrimitiveMethodName.CREATE_INSTANCE) {
						type = FunctionInvocationType.CONSTRUCTOR;
						classValue = ((ClassValue) value.internalValue);
						if (classValue.isInterface) {
							return Core.GenerateException(CoreExceptionTypes.UNSUPPORTED_OPERATION, "Cannot create an instance of an interface.");
						}
						classId = classValue.classId;
						if (!returnValueUsed) {
							return Core.GenerateException(CoreExceptionTypes.UNSUPPORTED_OPERATION, "Cannot create an instance and not use the output.");
						}
						classInfo = p.classTable[classId];
						functionId = classInfo.constructorFunctionId;
					} else {
						type = FunctionInvocationType.PRIMITIVE_METHOD;
					}
					break;
				default:
					Core.EmitComment("primitive method suspected.");
					functionId = resolvePrimitiveMethodName2(globalNameIdToPrimitiveMethodName, value.type, classId);
					if (functionId < 0) {
						return Core.GenerateException(CoreExceptionTypes.INVALID_INVOCATION, Core.StringConcatAll(getTypeFromId(value.type), " does not have that method."));
					}
					type = FunctionInvocationType.PRIMITIVE_METHOD;
					break;
			}
		}
	}
	if (type == FunctionInvocationType.POINTER_PROVIDED) {
		Core.EmitComment("pointer provided");
		valueStackSize -= 1;
		value = valueStack[valueStackSize];
		if (value.type == Types.FUNCTION) {
			functionPointer1 = ((FunctionPointer) value.internalValue);
			switch (functionPointer1.type) {
				case FunctionPointerType.FUNCTION:
					Core.EmitComment("pointer to a function");
					functionId = functionPointer1.functionId;
					type = FunctionInvocationType.NORMAL_FUNCTION;
					break;
				case FunctionPointerType.METHOD:
					Core.EmitComment("pointer to a method");
					functionId = functionPointer1.functionId;
					value = functionPointer1.context;
					type = FunctionInvocationType.LOCAL_METHOD;
					break;
				case FunctionPointerType.STATIC_METHOD:
					Core.EmitComment("pointer to a static method");
					functionId = functionPointer1.functionId;
					classId = functionPointer1.classId;
					type = FunctionInvocationType.STATIC_METHOD;
					break;
				case FunctionPointerType.PRIMITIVE_METHOD:
					Core.EmitComment("pointer to a primitive method");
					value = functionPointer1.context;
					functionId = functionPointer1.functionId;
					type = FunctionInvocationType.PRIMITIVE_METHOD;
					break;
			}
		} else {
			return Core.GenerateException(CoreExceptionTypes.INVALID_INVOCATION, "This type cannot be invoked like a function.");
		}
	}
	if (type == FunctionInvocationType.PRIMITIVE_METHOD) {
		Core.EmitComment("primitive method invocation");
		output = VALUE_NULL;
		primitiveMethodToCoreLibraryFallback = false;
		switch (value.type) {
			case Types.STRING:
				Core.EmitComment("...on a string");
				string1 = ((string) value.internalValue);
				switch (functionId) {
					case PrimitiveMethodName.CONTAINS:
						@import("PrimitiveMethods/string_contains.cry");
						break;
					case PrimitiveMethodName.ENDS_WITH:
						@import("PrimitiveMethods/string_ends_with.cry");
						break;
					case PrimitiveMethodName.INDEX_OF:
						@import("PrimitiveMethods/string_index_of.cry");
						break;
					case PrimitiveMethodName.LOWER:
						@import("PrimitiveMethods/string_lower.cry");
						break;
					case PrimitiveMethodName.LTRIM:
						@import("PrimitiveMethods/string_ltrim.cry");
						break;
					case PrimitiveMethodName.REPLACE:
						@import("PrimitiveMethods/string_replace.cry");
						break;
					case PrimitiveMethodName.REVERSE:
						@import("PrimitiveMethods/string_reverse.cry");
						break;
					case PrimitiveMethodName.RTRIM:
						@import("PrimitiveMethods/string_rtrim.cry");
						break;
					case PrimitiveMethodName.SPLIT:
						@import("PrimitiveMethods/string_split.cry");
						break;
					case PrimitiveMethodName.STARTS_WITH:
						@import("PrimitiveMethods/string_starts_with.cry");
						break;
					case PrimitiveMethodName.TRIM:
						@import("PrimitiveMethods/string_trim.cry");
						break;
					case PrimitiveMethodName.UPPER:
						@import("PrimitiveMethods/string_upper.cry");
						break;
					default:
						output = null;
						break;
				}
				break;
			case Types.LIST:
				Core.EmitComment("...on a list");
				list1 = ((List<Value>) value.internalValue);
				switch (functionId) {
					case PrimitiveMethodName.ADD:
						@import("PrimitiveMethods/list_add.cry");
						break;
					case PrimitiveMethodName.CHOICE:
						@import("PrimitiveMethods/list_choice.cry");
						break;
					case PrimitiveMethodName.CLEAR:
						@import("PrimitiveMethods/list_clear.cry");
						break;
					case PrimitiveMethodName.CLONE:
						@import("PrimitiveMethods/list_clone.cry");
						break;
					case PrimitiveMethodName.CONCAT:
						@import("PrimitiveMethods/list_concat.cry");
						break;
					case PrimitiveMethodName.CONTAINS:
						@import("PrimitiveMethods/list_contains.cry");
						break;
					case PrimitiveMethodName.FILTER:
						@import("PrimitiveMethods/list_filter.cry");
						break;
					case PrimitiveMethodName.INSERT:
						@import("PrimitiveMethods/list_insert.cry");
						break;
					case PrimitiveMethodName.JOIN:
						@import("PrimitiveMethods/list_join.cry");
						break;
					case PrimitiveMethodName.MAP:
						@import("PrimitiveMethods/list_map.cry");
						break;
					case PrimitiveMethodName.POP:
						@import("PrimitiveMethods/list_pop.cry");
						break;
					case PrimitiveMethodName.REMOVE:
						@import("PrimitiveMethods/list_remove.cry");
						break;
					case PrimitiveMethodName.REVERSE:
						@import("PrimitiveMethods/list_reverse.cry");
						break;
					case PrimitiveMethodName.SHUFFLE:
						@import("PrimitiveMethods/list_shuffle.cry");
						break;
					case PrimitiveMethodName.SORT:
						@import("PrimitiveMethods/list_sort.cry");
						break;
					default:
						output = null;
						break;
				}
				break;
			case Types.DICTIONARY:
				Core.EmitComment("...on a dictionary");
				dictImpl = ((DictImpl) value.internalValue);
				switch (functionId) {
					case PrimitiveMethodName.CLEAR:
						@import("PrimitiveMethods/dict_clear.cry");
						break;
					case PrimitiveMethodName.CLONE:
						@import("PrimitiveMethods/dict_clone.cry");
						break;
					case PrimitiveMethodName.CONTAINS:
						@import("PrimitiveMethods/dict_contains.cry");
						break;
					case PrimitiveMethodName.GET:
						@import("PrimitiveMethods/dict_get.cry");
						break;
					case PrimitiveMethodName.KEYS:
						@import("PrimitiveMethods/dict_keys.cry");
						break;
					case PrimitiveMethodName.MERGE:
						@import("PrimitiveMethods/dict_merge.cry");
						break;
					case PrimitiveMethodName.REMOVE:
						@import("PrimitiveMethods/dict_remove.cry");
						break;
					case PrimitiveMethodName.VALUES:
						@import("PrimitiveMethods/dict_values.cry");
						break;
					default:
						output = null;
						break;
				}
				break;
			case Types.FUNCTION:
				Core.EmitComment("...on a function pointer");
				functionPointer1 = ((FunctionPointer) value.internalValue);
				switch (functionId) {
					case PrimitiveMethodName.ARG_COUNT_MAX:
						@import("PrimitiveMethods/function_arg_count_max.cry");
						break;
					case PrimitiveMethodName.ARG_COUNT_MIN:
						@import("PrimitiveMethods/function_arg_count_min.cry");
						break;
					case PrimitiveMethodName.GET_NAME:
						@import("PrimitiveMethods/function_get_name.cry");
						break;
					case PrimitiveMethodName.INVOKE:
						@import("PrimitiveMethods/function_invoke.cry");
						break;
					default:
						output = null;
						break;
				}
				break;
			case Types.CLASS:
				Core.EmitComment("...on a class definition");
				classValue = ((ClassValue) value.internalValue);
				switch (functionId) {
					case PrimitiveMethodName.GET_NAME:
						@import("PrimitiveMethods/class_get_name.cry");
						break;
					case PrimitiveMethodName.IS_A:
						@import("PrimitiveMethods/class_is_a.cry");
						break;
					default:
						output = null;
						break;
				}
				break;
		}
		if (output == null) {
			if (primitiveMethodToCoreLibraryFallback) {
				type = FunctionInvocationType.NORMAL_FUNCTION;
				bool1 = true;
			} else {
				return Core.GenerateException(CoreExceptionTypes.INVALID_INVOCATION, "primitive method not found.");
			}
		} else {
			if (returnValueUsed) {
				@import("ValueStackCapacityCheck.cry");
				valueStack[valueStackSize] = output;
				valueStackSize += 1;
			}
			bool1 = false;
		}
	}
	if (bool1) {
		Core.EmitComment("push a new frame to the stack");
		stack.pc = pc;
		bool1 = false;
		switch (type) {
			case FunctionInvocationType.NORMAL_FUNCTION:
				Core.EmitComment("function");
				functionInfo = functionTable[functionId];
				pc = functionInfo.pc;
				value = null;
				classId = 0;
				break;
			case FunctionInvocationType.STATIC_METHOD:
				Core.EmitComment("static method");
				functionInfo = functionTable[functionId];
				pc = functionInfo.pc;
				value = null;
				classId = 0;
				break;
			case FunctionInvocationType.LOCAL_METHOD:
				Core.EmitComment("non-static method");
				functionInfo = functionTable[functionId];
				pc = functionInfo.pc;
				classId = 0;
				break;
			case FunctionInvocationType.CONSTRUCTOR:
				Core.EmitComment("constructor");
				p.instanceCounter += 1;
				classInfo = classTable[classId];
				valueArray1 = new Array<Value>(classInfo.memberCount);
				for (i = valueArray1.Length - 1; i >= 0; i -= 1) {
					switch (classInfo.fieldInitializationCommand[i]) {
						case 0:
							valueArray1[i] = classInfo.fieldInitializationLiteral[i];
							break;
						case 1:
							valueArray1[i] = new Value(Types.LIST, new List<Value>());
							break;
						case 2:
							valueArray1[i] = new Value(Types.DICTIONARY, new DictImpl(new Dictionary<int, Value>(), new Dictionary<int, Value>(), new Dictionary<string, Value>(), new Dictionary<string, Value>(), 0, Types.INTEGER));
							break;
					}
				}
				objInstance1 = new ObjectInstance(classId, p.instanceCounter, valueArray1, null);
				value = new Value(Types.INSTANCE, objInstance1);
				functionId = classInfo.constructorFunctionId;
				functionInfo = functionTable[functionId];
				pc = functionInfo.pc;
				classId = 0;
				if (returnValueUsed) {
					returnValueUsed = false;
					@import("ValueStackCapacityCheck.cry");
					valueStack[valueStackSize] = value;
					valueStackSize += 1;
				}
				break;
			case FunctionInvocationType.BASE_CONSTRUCTOR:
				Core.EmitComment("base constructor");
				value = stack.objectContext;
				classInfo = classTable[classId];
				functionId = classInfo.constructorFunctionId;
				functionInfo = functionTable[functionId];
				pc = functionInfo.pc;
				classId = 0;
				break;
		}
		if ((argCount < functionInfo.minArgs) || (argCount > functionInfo.maxArgs)) {
			pc = stack.pc;
			return Core.GenerateException(CoreExceptionTypes.INVALID_ARGUMENT, "Incorrect number of args were passed to this function.");
		}
		int1 = functionInfo.localsSize;
		int2 = stack.localsStackOffsetEnd;
		if (localsStackCapacity <= (int2 + int1)) {
			increaseLocalsStackCapacity(ec, int1);
			localsStack = ec.localsStack;
			localsStackSet = ec.localsStackSet;
			localsStackCapacity = localsStack.Length;
		}
		localsStackSetToken += 1;
		if (localsStackSetToken > 2000000000) {
			resetLocalsStackTokens(ec, stack);
			localsStackSetToken = 2;
		}
		localsStackOffset = int2;
		Core.EmitComment("invoke the function");
		stack = new StackFrame(pc, localsStackSetToken, localsStackOffset, (localsStackOffset + int1), stack, returnValueUsed, value, valueStackSize, 0, (stack.depth + 1), PostFinallyBehavior.NOTHING, null);
		for (i = 0; i < argCount; i += 1) {
			int1 = localsStackOffset + i;
			localsStack[int1] = funcArgs[i];
			localsStackSet[int1] = localsStackSetToken;
		}
		if (argCount != functionInfo.minArgs) {
			int1 = argCount - functionInfo.minArgs;
			if (int1 > 0) {
				pc += functionInfo.pcOffsetsForOptionalArgs[int1];
				stack.pc = pc;
			}
		}
		if (stack.depth > 1000) {
			return Core.GenerateException(CoreExceptionTypes.FATAL, "Stack overflow.");
		}
	}
}

import Math;
import Game;

namespace Audio {

    enum _MusicState {
        NOT_PLAYING = 1,
        TRANSITION_IN = 2,
        PLAYING_NORMAL = 3,
        PLAYING_LOOPING = 4,
        TRANSITION_OUT = 5,
    }

    class MusicNotFoundException : Exception {
        constructor(m) : base(m) { }
    }

    /*
        nativeData[0] -> native music object, if necessary. Some platforms just do everything by path.
    */
    class Music {

        static field _isSupported = $$lib_audio_is_supported();

        field _isResource;
        field _path;

        @private
        constructor() {
            // Initialized by factory methods.
        }

        static function _convertPath(path) {
            fileinfo = $$lib_audio_getAudioResourcePath(path + '');
            if (fileinfo == null) {
                throw new MusicNotFoundException("Audio resource '" + path + "' not found.");
            } else if (!fileinfo[0]) {
                throw new Core.InvalidArgumentException("Resource '" + path + "' is not an audio file.");
            }
            return fileinfo[1];
        }

        static function loadFromResource(path) {

            path = Music._convertPath(path);

            music = new Music();
            music._isResource = true;
            music._path = path;
            if (!$$lib_audio_music_load_from_resource(music, path)) {
                throw new MusicNotFoundException("Music resource '" + path + "' not found.");
            }
            return music;
        }

        static field currentState = _MusicState.NOT_PLAYING;
        static field currentMusic = null;
        static field currentIsLoop = false;
        static field currentInTransitionDuration = null;
        static field currentOutTransitionDuration = null;
        static field currentTransitionStart = null;

        static field enqueuedMusic = null;
        static field enqueuedIsLoop = null;
        static field enqueuedInTransitionDuration = null;

        static field mainVolume = 1.0; // overall volume
        static field compositeVolume = 1.0; // volume with fades and song normalization applied
        static field fadeVolume = 1.0;

        static constructor() {
            Game.GameWindow._frameEndHandlers.add(Music._gameWindowFrameEndHandler);
        }

        static function _gameWindowFrameEndHandler() {
            switch (Music.currentState) {
                case _MusicState.NOT_PLAYING:
                    // nothing to do
                    break;

                case _MusicState.TRANSITION_IN:
                    dt = Core.currentTime() - Music.currentTransitionStart;
                    if (dt >= Music.currentInTransitionDuration) {
                        Music.fadeVolume = 1.0;
                        Music.currentState = Music.currentIsLoop ? _MusicState.PLAYING_LOOPING : _MusicState.PLAYING_NORMAL;
                    } else {
                        Music.fadeVolume = 1.0 * dt / Music.currentInTransitionDuration;
                    }
                    break;

                case _MusicState.PLAYING_NORMAL:
                    if (!$$lib_audio_music_is_playing()) {
                        // Rather than just mark this as no longer playing, pretend that it's a transition out that's already done.
                        // This will either mark it as NOT_PLAYING or will automatically pop the queue and start the next song.
                        // Otherwise enqueuing a song during a non-looping song and if the song just happens to end while it's still fading
                        // the next song won't get triggered and that will make users cry.
                        Music.currentState = _MusicState.TRANSITION_OUT;
                        Music.currentTransitionStart = 0;
                        Music.currentOutTransitionDuration = 1.0;
                    }
                    break;

                case _MusicState.PLAYING_LOOPING:
                    // carry on.
                    break;

                case _MusicState.TRANSITION_OUT:
                    dt = Core.currentTime() - Music.currentTransitionStart;
                    if (dt == null || dt >= Music.currentOutTransitionDuration) {
                        Music.fadeVolume = 0.0;
                        // music fade complete.
                        if (Music.enqueuedMusic == null) {
                            Music.currentState = _MusicState.NOT_PLAYING;
                            Music.currentMusic = null;
                            $$lib_audio_music_stop();
                        } else {
                            Music.currentMusic = Music.enqueuedMusic;
                            Music.currentIsLoop = Music.enqueuedIsLoop;
                            if (Music.enqueuedInTransitionDuration == null) {
                                found = $$lib_audio_music_play(
                                    Music.currentMusic,
                                    Music.currentMusic._isResource,
                                    Music.currentMusic._path,
                                    Music.mainVolume,
                                    Music.currentIsLoop);
                                if (!found) throw new Audio.MusicNotFoundException("Music file not found: " + Music.currentMusic._path);

                                Music.currentState = Music.currentIsLoop
                                    ? _MusicState.PLAYING_LOOPING
                                    : _MusicState.PLAYING_NORMAL;
                                Music.currentInTransitionDuration = null;
                                Music.fadeVolume = 1.0;
                            } else {
                                $$lib_audio_music_play(
                                    Music.currentMusic,
                                    Music.currentMusic._isResource,
                                    Music.currentMusic._path,
                                    0.0,
                                    Music.currentIsLoop);
                                Music.currentState = _MusicState.TRANSITION_IN;
                                Music.currentInTransitionDuration = Music.enqueuedInTransitionDuration;
                                Music.currentTransitionStart = Core.currentTime();
                            }
                            Music.enqueuedMusic = null;
                        }
                    } else {
                        Music.fadeVolume = 1.0 - dt / Music.currentOutTransitionDuration;
                    }
                    break;
            }

            v = Math.ensureRange(Music.fadeVolume * Music.mainVolume, 0.0, 1.0);
            diff = Math.abs(v - Music.compositeVolume);
            if (diff > 0.00001) {
                Music.compositeVolume = v;
                $$lib_audio_music_set_volume(v);
            }
        }

        static function getCurrent() {
            return Music.currentMusic;
        }

        function fadeOutAndIn(loop = true, outTransition = 2.0, inTransition = 2.0) {
            Music._transition(this, loop, outTransition, inTransition);
        }

        function fadeOutAndPlay(loop = true, outTransition = 2.0) {
            Music._transition(this, loop, outTransition, null);
        }

        function play(loop = true) {
            Music._transition(this, loop, null, null);
        }

        function fadeOut(duration = 2.0) {
            if (Music.currentMusic == this) {
                Music.fadeOutCurrent(duration);
            }
        }

        static function fadeOutCurrent(duration = 2.0) {
            Music._transition(null, false, duration, null);
        }

        static function stop() {
            Music._transition(null, false, null, null);
        }

        function fadeIn(loop = true, duration = 2.0) {
            Music._transition(this, loop, null, duration);
        }

        /*
            music can be null to indicate a top
            outTransition can be null to indicate instant end
            inTransition can be null to indicate instant start
        */
        static function _transition(music, loop, outTransitionDuration, inTransitionDuration) {
            if (inTransitionDuration == null || inTransitionDuration < 0.01) inTransitionDuration = null;
            if (outTransitionDuration == null || outTransitionDuration < 0.01) outTransitionDuration = null;
            if (music == Music.currentMusic) return;
            loop = loop == true;

            if (outTransitionDuration == null) {
                // instantaneous transitions
                if (music == null) {
                    $$lib_audio_music_stop();
                    Music.currentMusic = null;
                    Music.currentState = _MusicState.NOT_PLAYING;
                } else {
                    Music.currentMusic = music;
                    Music.currentIsLoop = loop;
                    if (inTransitionDuration == null) {
                        Music.currentState = loop ? _MusicState.PLAYING_LOOPING : _MusicState.PLAYING_NORMAL;
                        Music.fadeVolume = 1.0;
                        $$lib_audio_music_play(music, music._isResource, music._path, Music.mainVolume, loop);
                    } else {
                        Music.currentState = _MusicState.TRANSITION_IN;
                        Music.fadeVolume = 0.0;
                        Music.currentTransitionStart = Core.currentTime();
                        Music.currentInTransitionDuration = inTransitionDuration;
                        $$lib_audio_music_play(music, music._isResource, music._path, 0.0, loop);
                    }
                }
            } else {
                // fade out. save transition information for the end-frame worker.
                Music.currentState = _MusicState.TRANSITION_OUT;
                Music.currentTransitionStart = Core.currentTime();
                Music.currentOutTransitionDuration = outTransitionDuration;
                Music.enqueuedMusic = music;
                Music.enqueuedInTransitionDuration = inTransitionDuration;
                Music.enqueuedIsLoop = loop;
            }
        }
    }

    enum SoundPlayState {
        PLAYING = 1,
        PAUSED = 2,
        STOPPED = 3,
    }

    /*
        nativeData[0] -> mixer channel identifier or whatever is necessary to identify this particular playing instance.
    */
    class Sound {
        field _soundResource;
        field _id;

        field _isStopped = false; // set to stopped to indicate the sound should never be resumable again.
        field _volume;
        field _pan;

        // constructs and fires event
        constructor(resource, volume, pan) {
            this._soundResource = resource;
            this._id = resource._id;
            this._volume = volume;
            this._pan = pan;

            // This call will set the native data.
            // Also, it'll just mark the sound as stopped if there's an error.
            // TODO: maybe a better indicator of an error playing the sound.
            this._isStopped = $$lib_audio_sfx_play(this, resource, volume, pan) == 1;
        }

        function getState() {
            // ensures that it also returns STOPPED if the channel is playing a different sound.
            t = $$lib_audio_sfx_get_state(this, this._soundResource, this._id);
            if (t == SoundPlayState.STOPPED) this._isStopped = true;
            return t;
        }

        function resume() {
            if (this.getState() == SoundPlayState.PAUSED) {
                $$lib_audio_sfx_resume(this, this._soundResource, this._volume, this._pan);
            }
        }

        function stop() {
            t = this.getState();
            if (t != SoundPlayState.STOPPED) {
                $$lib_audio_sfx_stop(this, this._soundResource, this._id, t, true);
            }
        }

        function pause() {
            if (this.getState() == SoundPlayState.PLAYING) {
                $$lib_audio_sfx_stop(this, this._soundResource, this._id, SoundPlayState.PLAYING, false);
            }
        }

        function getResource() {
            return this._soundResource;
        }

        /*
            -1.0 -> left speaker only
            1.0 -> right speaker only
            0.0 -> balanced
        */
        function setPan(value) {
            this._pan = Math.ensureRange(value, -1.0, 1.0) + 0.0;
            $$lib_audio_sfx_set_pan(this, this._soundResource, this._pan);
        }

        function getPan() { return this._pan; }

        /*
            ratio from 0.0 to 1.0
        */
        function setVolume(ratio) {
            this._volume = Math.ensureRange(ratio, 0.0, 1.0) + 0.0;
            $$lib_audio_sfx_set_volume(this, this._soundResource, this._volume);
        }

        function getVolume() { return this._volume; }
    }

    /*
        native_data[0] -> actual native instance of the sound.
    */
    class SoundResource {

        static field _cache = {};

        static field _resID = 0;

        field _v = 1.0; // volume
        field _p; // path
        field _e; // is embedded resource
        field _c = []; // playing channels

        field _id; // unique ID for this particular resource

        @private
        constructor() {
            this._id = SoundResource._resID++;
        }

        function setDefaultVolume(r) {
            this._v = Math.ensureRange(r, 0.0, 1.0) + 0.0;
        }

        function getDefaultVolume() {
            return this._v;
        }

        static function loadFromFile(path) {

            s = new SoundResource();
            $$lib_audio_sfx_load_from_file(s, path);
            s._p = path;
            s._e = false;
            return s;
        }

        static function loadFromResource(path, useCache = true) {

            s = null;
            path += ''; // ensure string
            if (useCache) {
                s = SoundResource._cache.get(path);
            }
            if (s == null) {
                path = Music._convertPath(path);
                s = new SoundResource();
                $$lib_audio_sfx_load_from_resource(s, path);
                s._p = path;
                s._e = true;
                if (useCache) {
                    SoundResource._cache[path] = s;
                }
            }
            return s;
        }

        function play(pan = 0.0) {
            c = new Sound(this, this._v, pan);
            this._c.add(c);
            return c;
        }
    }
}

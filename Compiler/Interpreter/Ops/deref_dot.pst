// row[0] -> global name ID
// row[1] -> locale scoped name ID
// row[2] -> origin class ID
// row[3] -> [MUTABLE] last successful class ID that was dereferenced here or -1 if none.
// row[4] -> [MUTABLE] member ID of the last successful class ID that was dereferenced here

value = valueStack[valueStackSize - 1];
nameId = row[0];
int2 = row[1]; // locale scoped name ID
switch (value.type) {
    case Types.INSTANCE:
        objInstance1 = (ObjectInstance) value.internalValue;
        classId = objInstance1.classId;
        classInfo = classTable[classId];
        if (classId == row[3]) {
            int1 = row[4];
        } else {
            intIntDict1 = classInfo.localeScopedNameIdToMemberId;
            int1 = intIntDict1.TryGet(int2, -1);

            int3 = classInfo.fieldAccessModifiers[int1];
            if (int3 > 1) { // if not public...
                if (int3 == 2) { // if private
                    if (objInstance1.classId != row[2]) {
                        int1 = -2; // nope. can't do that.
                    } else {
                        if (int3 == 3 || int3 == 5) {
                            // TODO: is internal?
                        }

                        if (int3 == 4 || int3 == 5) {
                            // TODO: is protected?
                        }
                    }
                }
            }

            row[3] = objInstance1.classId;
            row[4] = int1;
        }

        if (int1 > -1) {

            functionId = classInfo.functionIds[int1];
            if (functionId == -1) {
                output = objInstance1.members[int1];
            } else {
                output = new Value(Types.FUNCTION, new FunctionPointer(
                    FunctionPointerType.METHOD,
                    value, // object instance
                    objInstance1.classId,
                    functionId,
                    null));
            }
        } else {
            output = null;
        }
        break;

    case Types.STRING:
        if (metadata.lengthId == nameId) {
            output = buildInteger(globals, Core.ForceParens(((string) value.internalValue)).Size());
        } else {
            output = null;
        }
        break;

    case Types.LIST:
        if (metadata.lengthId == nameId) {
            output = buildInteger(globals, Core.ForceParens((List<Value>) value.internalValue).Size());
        } else {
            output = null;
        }
        break;

    case Types.DICTIONARY:
        if (metadata.lengthId == nameId) {
            output = buildInteger(globals, Core.ForceParens((DictImpl) value.internalValue).size);
        } else {
            output = null;
        }
        break;

    default:
        if (value.type == Types.NULL) {
            hasInterrupt = EX_NullReference(ec, "Derferenced a field from null.");
            output = VALUE_NULL;
        } else {
            output = null;
        }
        break;
}

if (output == null) {
    output = generatePrimitiveMethodReference(globalNameIdToPrimitiveMethodName, nameId, value);
    if (output == null) {
        // TODO: put this all in a helper function.
        if (value.type == Types.NULL) {
            hasInterrupt = EX_NullReference(ec, "Tried to dereference a field on null.");
        } else if (value.type == Types.INSTANCE && int1 == -2) {
            hasInterrupt = EX_UnknownField(ec, "This field is marked as private and cannot be accessed from outside its class.");
        } else {
            if (value.type == Types.INSTANCE) {
                classId = Core.ForceParens((ObjectInstance) value.internalValue).classId;
                classInfo = classTable[classId];
                string1 = Core.StringConcatAll(classInfo.fullyQualifiedName, " instance");
            } else {
                string1 = getTypeFromId(value.type);
            }

            hasInterrupt = EX_UnknownField(ec, Core.StringConcatAll(string1, " does not have that field."));
        }
    }
}

valueStack[valueStackSize - 1] = output;

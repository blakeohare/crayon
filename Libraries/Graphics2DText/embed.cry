/*
    On some level, some sort of font resource needs to be cached.
    What is defined as a font resource varies from platform to platform
    
    For Python, it's the font face, size, style
    
    For Java, it's just the font
    
    For JavaScript, there's nothing. You pass the font name as a string to the draw context for each use
    - although, for JS, the process for checking if a font is a little weird.

    For OpenGL a collection of texture atlases are created.
    - first each character is rendered at size 36 in individual images
    - these characters are stored in a several layer cache
    - each time a character is used it's moved to the top cache
    - every minute or so each cache layer is demoted
    - every once in a while a series of textures are created
    - if there are less than 200 characters rendered by the font, no cache churning occurs
    - each cache/texture system is keyed off font face, size, and style
    - coloring is handled by the fragment shader
    - note that rendering rapidly changing characters (of something like chinese) at size 72 could kill performance, but that's an edge case
*/
namespace Graphics2DText {

    /*
        Wraps a native font font instance.
        Almost all platforms have some sort of notion of a font object.
        What properties of a font constitutes a unique font object varies, though.
        This class encompasses whatever that notion is.

        nativeData[0] -> native font instance


    */
    class NativeFontInstance {

        field key;

        static field _nativeFontInstances = {};

        @private
        constructor(type, id, size, style, r, g, b) {
            this.key = NativeFontInstance.getUniqueKey(type, id, size, r, g, b, style);
            $$$('allocNativeData', 1);
            output = [0] * 2;
            $$lib_graphics2dtext_createNativeFont(this, type, id, size, r, g, b, style, output);
            status = output[0];
            switch (output[0]) {
                case 0: break; // all is fine
                case 1: throw new FontNotFoundException("Font not installed: '" + output[1] + "'");
                case 2: throw new FontNotFoundException("Font resource not found: '" + output[1] + "'");
                default: throw new Exception(); // this won't happen
            }
        }

        static function get(type, id, size, style, r, g, b) {
            key = NativeFontInstance.getUniqueKey(type, id, size, r, g, b, style);
            nativeFont = NativeFontInstance._nativeFontInstances.get(key);
            if (nativeFont == null) {
                nativeFont = new NativeFontInstance(type, id, size, style, r, g, b);
                NativeFontInstance._nativeFontInstances[key] = nativeFont;
            }
        }

        static function getUniqueKey(type, id, size, r, g, b, style) {
            output = [];
            $$lib_graphics2dtext_getNativeFontUniqueKey(
				// convert everything to strings
				type + '', id + '', size + '', r + '', g + '', b + '', style + '',
				output);
            return output.join('|');
        }
    }

    class FontNotFoundException : Core.Exception { 
		constructor(m) : base (m, null) { }
    }

    enum FontSourceType {
        DEFAULT = 0,
        RESOURCE = 1,
        FILE = 2,
        SYSTEM = 3,
    }

    enum FontClass {
        SERIF = 1,
        SANS_SERIF = 2,
        MONOSPACE = 3,
    }

    enum FontStyle {
        NORMAL = 0,
        BOLD = 1,
        ITALIC = 2,
        BOLD_ITALIC = 3, // bit mask of BOLD | ITALIC
    }

    class FontRenderer {
        field font;
        field size = 12;
        field style = FontStyle.NORMAL;
        field r = 255;
        field g = 255;
        field b = 255;

        field _native = null;
        field _settingsKey = null;
        static field _textureCache = {};

        constructor(font) {
            if (!(font is Graphics2DText.FontResource)) throw new InvalidArgumentException("Expected a FontResource instance");
            this.font = font;
        }

        function setColor(r, g, b) {
            // TODO: verify args
            this.r = r;
            this.g = g;
            this.b = b;
            this._native = null;
            this._settingsKey = null;
            return this;
        }

        function setSize(size) {
            // TODO: verify args
            this.size = size;
            this._native = null;
            this._settingsKey = null;
            return this;
        }

        function setStyle(style) {
            // TODO: verify args
            this.style = style;
            this._native = null;
            this._settingsKey = null;
            return this;
        }

        function render(text) {
            if (this._native == null) {
                this._native = NativeFontInstance.get(
					this.font._sourceType, this.font._sourceId, 
					this.size, this.style, this.r, this.g, this.b);
				
				// don't recycle the native font key for this since the native key will
				// drop attributes that aren't part of an allocated font face instance.
				// We need all attributes in this key.
                this._settingsKey = 
					[
						this.font._sourceType, this.font._source, 
						this.size,
						this.style, 
						this.r, this.g, this.b
					].join(':');
            }

            textureKey = this._settingsKey + '\n' + text;
            texture = FontRenderer._textureCache.get(textureKey);
            if (texture == null) {
                texture = new TextSurface(this);
                FontRenderer._textureCache[textureKey] = texture;
            }

            return texture;
        }
    }

    class FontResource {
        field _sourceType;
        field _source;

        @private
        constructor(source, sourceType) {
            this._source = source;
            this._sourceType = sourceType;
        }

        function getRenderer() {
            return new FontRenderer(this);
        }
        
        static field _cache = {};

        static function _getKey(sourceType, source) {
            return sourceType + source;
        }

        static function _get(sourceType, source) {
            key = sourceType + source;
            font = FontResource._cache.get(key);
            if (font == null) {
                font = new FontResource(sourceType, source);
                FontResource._cache[key] = font;
            }
            return font;
        }

        static function fromResource(path) {
            if (!$$lib_graphics2dtext_isResourceAvailable(path)) {
                throw new FontNotFoundException("Font resource not found: '" + path + "'");
            }
            return FontResource._get(FontSourceType.RESOURCE, path);
        }

        static function fromDisk(path) {
            throw new NotImplementedException();
        }

        static function fromSystem(name) {
            if (!FontResource.isSystemFontPresent(name)) {
                throw new FontNotFoundException("Font not installed: '" + name + "'");
            }
            return FontResource._get(FontSourceType.SYSTEM, name);
        }

        static function isSystemFontPresent(name) {
            return $$lib_graphics2dtext_isSystemFontPresent(name);
        }

        static function getDefaultSerifFont() {
            return FontResource._get(FontSourceType.DEFAULT, FontClass.SERIF);
        }

        static function getDefaultSansSerifFont() {
            return FontResource._get(FontSourceType.DEFAULT, FontClass.SANS_SERIF);
        }

        static function getDefaultMonospaceFont() {
            return FontResource._get(FontSourceType.DEFAULT, FontClass.MONOSPACE);
        }
    }

    /*
        Presents itself as something similar to a GraphicsTexture that can be drawn to the screen.
        The actual implementation may vary depending on the platform.
        It may either be a cached image or a set of drawing instructions.
    */
    class TextSurface {
        field _glRenderer = null;
        field width;
        field height;

        constructor(fontRenderer, text) {
            /*
                for bitmap based platforms:
                nativeData[0] -> a native image object such as a pygame.Surface or JS canvas
                
                for GL based platforms:
                nativeData[0] -> unused
                nativeData[1] -> an int[] of x coordinates
                nativeData[2] -> an int[] of y coordinates
                nativeData[3] -> an int[] of character codes
                nativeData[4] -> red
                nativeData[5] -> green
                nativeData[6] -> blue
            */
            
            if ($$$lib_graphics2dtext_isGlRenderer()) {
				$$$('allocNativeData', this, 7);
            } else {
				$$$('allocNativeData', this, 1);
				
                sizeOut = [0, 0];
                $$lib_graphics2dtext_renderText(
                    sizeOut,
                    this,
                    fontRenderer._native,
                    fontRenderer.font._sourceType,
                    fontRenderer.font._source,
                    fontRenderer.size,
                    fontRenderer.style,
                    fontRenderer.r,
                    fontRenderer.g,
                    fontRenderer.b,
                    text);
                this.width = sizeOut[0];
                this.height = sizeOut[1];
            }
            
        }

		function _refreshGlRenderer() {
			this._glRenderer
		}

        function draw(x, y) {
            throw new NotImplementedException();
        }

        function drawWithAlpha(x, y) {
            throw new NotImplementedException();
        }
    }

    //////////////////////
    // Below are all the classes required for GL rendering.
    // Since there's so much bookkeeping, it's best to do this in high-level Crayon code.
    // This is a waste of byte code for non-GL platforms, but that's okay.
    //////////////////////

    /*
        A GL renderer juggles around some textures
        
        A GL instance always stays alive.
        They are only created on a unique (font, style, size) basis
        They will unload their textures if unused and will essentially take up no space, so having a
		lifetime tied to the life of the app is okay.
    */
    class GLRenderer {
        /*
            nativeData[0] -> some sort of native font resource the system can use to generate
                bitmaps that can be loaded as textures.
                This is a little more heavy duty than the NativeFontInstance as it contains 
                size and style information too.
            nativeData[1] -> a nullable int-to-int dictionary that maps char code ID's to texture ID's
                set to null to invalidate and reconstruct
        */

        field sheets = [];
        field sheetByCharId = {};
        field tileByChardId = {};
        static field unknownChars = [];

		@private
		constructor() { }
		
		static function getRenderer(sourceType, sourceId, size, style) {
			key = font
		}

		function ensureCharactersExistAndCalculateSize(text, sizeOut) {
			width = 0;
			height = 0;
			newTiles = null;
			for (c : text) {
				if (c == ' ') c = 'v'; // use lowercase v for space allocation purposes
				if (c == '\n') throw new NotImplementedException();
				charId = Core.ord(c);
				tile = tileByCharId.get(charId);
				if (tile == null) {
					retry = true;
					tile = new GLTile(this, charId);
					if (newTiles == null) newTiles = [];
					newTiles.add(tile);
				}
				
				height = Math.max(height, tile.height);
				width = Math.max(width, tile.width);
			}
			
			if (newTiles != null) {
				// Just dump all of them into one new sheet.
				// The consolidator will run at the end of the frame and make the packing better.
				sheet = new GLTextureSheet(newTiles);
				
				// TODO: load textures
				throw new NotImplementedException();
			}
			
			sizeOut[0] = width;
			sizeOut[1] = height;
		}

        function render(textSurface) {
            status = $$lib_graphics2dtext_glRenderTextSurface(textSurface, GLRenderer.unknownChars);
            switch (status) {
                case 0: // it worked splendidly
                case 1: // some characters were unknown and need to be generated
                    tiles = [];
                    now = Core.currentTime();
                    for (charId : GLRenderer.unknownChars) {
                        tile = new GLTile(this, charId);
                        tile.lastUsed = now;
                        tiles.add(tile);
                    }
                    GLRenderer.unknownChars.clear();
                    // TODO: create a new texture
                    break;
            }
        }

        /*
            If there are two or more textures that are less than or equal to 512 x 512, then trigger a reconsolidation
            This is called once per frame.

            // TODO: add this to a Game frame end callback
        */
        function consolidate() {
            throw new NotImplementedException();
        }
    }

    /*
        nativeData[0] -> a bitmap instance
    */
    class GLTile {
        field charId;
        field width;
        field height;
        field currentTextureId;
        field sheet;
        field sheetX;
        field sheetY;
        field lastUsed;
        field renderer;

        constructor(renderer, charId) {
            this.charId = charId;
            this.renderer = renderer;
            $$$('allocNativeData', this, 1);
            size = [0, 0];
            $$lib_graphics2dtext_glRenderCharTile(renderer, this, charId, size);
            this.width = size[0];
            this.height = size[1];
        }
    }

    class GLTextureSheet {
        field id;
        field tiles;
        field tilesByCharId;
        field renderer;
    }
}

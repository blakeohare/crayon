using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;

namespace Interpreter
{
    public enum ImageFormat
    {
        PNG,
        JPEG,
    }

    /**
     * Wraps a System.Drawing.Bitmap in Windows or a MonoMac.CoreGraphics Bitmap on a Mac.
     */
    public class UniversalBitmap
    {
        private Image<Rgba32> bitmap;

        public bool IsValid { get; set; }
        public int Width { get; set; }
        public int Height { get; set; }

        public UniversalBitmap(string filepath)
        {
            this.IsValid = true;
            this.bitmap = Image.Load<Rgba32>(filepath.Replace('/', System.IO.Path.DirectorySeparatorChar));
            this.Width = this.bitmap.Width;
            this.Height = this.bitmap.Height;
        }

        public UniversalBitmap(byte[] bytes)
        {
            this.IsValid = true;
            // TODO: set IsValid to false if not valid
            this.bitmap = Image.Load(bytes);
            this.Width = this.bitmap.Width;
            this.Height = this.bitmap.Height;
        }

        public UniversalBitmap(int width, int height)
        {
            this.IsValid = true;
            this.Width = width;
            this.Height = height;
            this.bitmap = new Image<Rgba32>(width, height);
        }

        public byte[] GetBytesAsPng()
        {
            throw new System.NotImplementedException();
        }

        public byte[] GetBytesAsJpeg()
        {
            throw new System.NotImplementedException();
        }

        public UniversalBitmap CloneToNewSize(int width, int height)
        {
            UniversalBitmap newBitmap = new UniversalBitmap(width, height);
            DrawingSession g = newBitmap.MakeGraphics();
            if (width == this.Width && height == this.Height)
            {
                g.Blit(this, 0, 0);
            }
            else
            {
                g.BlitStretched(this, 0, 0, width, height);
            }
            return newBitmap;
        }

        public void Save(string path)
        {
            if (path.ToLowerInvariant().EndsWith(".ico"))
            {
                throw new System.NotImplementedException();
            }
            else
            {
                this.bitmap.Save(path);
            }
        }

        private static string FormatToExtension(ImageFormat format)
        {
            switch (format)
            {
                case ImageFormat.PNG: return ".png";
                case ImageFormat.JPEG: return ".jpg";
                default: throw new System.Exception();
            }
        }

        public byte[] SaveBytes(ImageFormat format)
        {
            throw new System.NotImplementedException();
        }

        public DrawingSession MakeGraphics()
        {
            return new DrawingSession(this);
        }

        public DrawingSession GetActiveDrawingSession()
        {
            throw new System.NotImplementedException();
        }

        public void GetPixel(int x, int y, int[] colorOut)
        {
            throw new System.NotImplementedException();
        }

        public class DrawingSession
        {
            public UniversalBitmap Bitmap { get; private set; }
            public DrawingSession Draw(UniversalBitmap bmp, int arg1, int arg2, int arg3, int arg4, int arg5, int arg6)
            {
                throw new System.NotImplementedException();
            }

            public DrawingSession SetPixel(int x, int y, int r, int g, int b, int a)
            {
                throw new System.NotImplementedException();
            }

            public DrawingSession Flush()
            {
                throw new System.NotImplementedException();
            }

            private Image<Rgba32> target;

            public DrawingSession(UniversalBitmap owner)
            {
                this.Bitmap = owner;
                this.target = owner.bitmap;
            }

            public void Blit(UniversalBitmap bmp, int x, int y)
            {
                this.BlitStretched(bmp, x, y, bmp.Width, bmp.Height);
            }

            public void BlitStretched(UniversalBitmap bmp, int x, int y, int stretchWidth, int stretchHeight)
            {
                int sourceWidth = bmp.Width;
                int sourceHeight = bmp.Height;
                int originalTargetLeft = x;
                int originalTargetTop = y;
                int targetLeft = System.Math.Max(0, originalTargetLeft);
                int targetTop = System.Math.Max(0, originalTargetTop);
                int originalTargetRight = originalTargetLeft + stretchWidth;
                int originalTargetBottom = originalTargetTop + stretchHeight;
                int targetRight = System.Math.Min(this.target.Width, originalTargetRight);
                int targetBottom = System.Math.Min(this.target.Height, originalTargetBottom);

                if (stretchWidth <= 0 || stretchHeight <= 0) return;

                int targetX, targetY, sourceX, sourceY;

                for (targetY = targetTop; targetY < targetBottom; ++targetY)
                {
                    sourceY = (targetY - originalTargetTop) * sourceHeight / stretchHeight;

                    for (targetX = targetLeft; targetX < targetRight; ++targetX)
                    {
                        sourceX = (targetX - originalTargetLeft) * sourceWidth / stretchWidth;
                        this.target[targetX, targetY] = bmp.bitmap[sourceX, sourceY];
                    }
                }
            }
        }
    }
}

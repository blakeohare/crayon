/*
    Read data from file.

    args[0]: disk host object
    args[1]: well-formed and sandboxed path
    args[2]: boolean (safe): read data as byte list?
    args[3]: output list.
        if byte mode: add bytes to this list
        if text mode: add a single Value string to this list

    Output: (int) status code (see FiocStatus enum in embed code)
*/
Value lib_fileiocommon_fileRead(VmContext vm, Array<Value> args) {
    Value diskHostObject = args[0];
    string sandboxedPath = (string) args[1].internalValue;
    bool readDataAsBytes = (bool) args[2].internalValue;
    ListImpl outputList = (ListImpl) args[3].internalValue;
    List<Value> tList = new List<Value>();

    // For strings requests, put the file contents into the stringOutParam
    // For raw byte requests, put the bytes directly onto the list and pass in the INTEGERS_CACHE
    int statusCode = Native._lib_fileiocommon_fileRead(
        lib_fileiocommon_getDiskObject(diskHostObject),
        sandboxedPath,
        readDataAsBytes,
        Core.StringBuffer16,
        vm.globals.positiveIntegers,
        tList);

    // If successful and this is a text request...
    if (statusCode == 0 && !readDataAsBytes) {
        // copy the value from stringOutParam to the list.
        addToList(outputList, buildString(vm.globals, Core.StringBuffer16[0]));
    } else {

        // This is kind of hacky
        // TODO: just return an int array from the native fileRead and return the
        // status via an out parameter. Native code should NOT have to deal with
        // the int value cache.
        if (@ext_boolean("ARRAY_IS_LIST")) {
            outputList.list = tList;
        } else {
            Value t = buildList(tList); // do list to array conversion
            ListImpl tListImpl = (ListImpl) t.internalValue;
            outputList.array = tListImpl.array;
            outputList.capacity = tListImpl.capacity;
        }
        outputList.size = tList.Size();
    }

    return buildInteger(vm.globals, statusCode);
}

using System;
using System.Collections.Generic;
using System.Linq;
using Interpreter.Structs;

namespace Interpreter.Vm
{
    public static class ImageUtil
    {
        public static object NewBitmap(int width, int height)
        {
            return new UniversalBitmap(width, height);
        }

        private static Dictionary<int, UniversalBitmap> loadedChunks = new Dictionary<int, UniversalBitmap>();
        public static void ChunkLoadAsync(int chunkId, int[] chunkIds, Value loadedCallback)
        {
            loadedChunks[chunkId] = ResourceReader.ReadImageResource("ch_" + chunkId + ".png");
            int total = chunkIds.Length;
            int loaded = 0;
            foreach (int otherChunk in chunkIds)
            {
                if (loadedChunks.ContainsKey(otherChunk)) loaded++;
            }
            EventLoop.ExecuteFunctionPointerNativeArgs(loadedCallback, new object[] { chunkId, loaded, total });
        }

        public static object GetChunk(int chunkId)
        {
            return loadedChunks[chunkId];
        }

        public static object Scale(object rawBmp, int newWidth, int newHeight, int algo)
        {
            if (algo != 1) throw new NotImplementedException();
            UniversalBitmap bmp = (UniversalBitmap)rawBmp;
            int oldWidth = bmp.Width;
            int oldHeight = bmp.Height;

            if (oldWidth == newWidth && oldHeight == newHeight)
            {
                // Scale is used for 1:1 cloning
                UniversalBitmap clone = new UniversalBitmap(newWidth, newHeight);
                clone.GetActiveDrawingSession().Draw(bmp, 0, 0, 0, 0, newWidth, newHeight).Flush();
                return clone;
            }

            throw new NotImplementedException();
        }

        public static object StartEditSession(object bmpObj)
        {
            UniversalBitmap bmp = (UniversalBitmap)bmpObj;
            UniversalBitmap.DrawingSession session = bmp.GetActiveDrawingSession();
            return session;
        }

        public static void EndEditSession(object sessionObj, object bmpObj)
        {
            UniversalBitmap.DrawingSession session = (UniversalBitmap.DrawingSession)sessionObj;
            session.Flush();
        }

        public static void Blit(object targetObj, object srcObj, int sx, int sy, int sw, int sh, int tx, int ty, int tw, int th)
        {
            UniversalBitmap.DrawingSession target = (UniversalBitmap.DrawingSession)targetObj;
            UniversalBitmap src = (UniversalBitmap)srcObj;
            if (tw != sw || th != sh) throw new NotImplementedException();
            target.Draw(src, tx, ty, sx, sy, tw, th);
        }

        public static void GetPixel(object bmpRaw, object nullableEditSession, int x, int y, int[] colorOut)
        {
            UniversalBitmap bmp = (UniversalBitmap)bmpRaw;
            if (x < 0 || y < 0 || x >= bmp.Width || y >= bmp.Height)
            {
                colorOut[4] = 0;
                return;
            }
            colorOut[4] = 1;
            bmp.GetPixel(x, y, colorOut);
            return;
        }

        // returns true for out of range
        public static bool SetPixel(object sessionObj, int x, int y, int r, int g, int b, int a)
        {
            // TODO: this is a HACK and WRONG. This should not flush the whole image to the original bitmap.
            // Since most people will just open the session, make changes, and then flush it, this will
            // be functionally correct under 90% of normal use cases.
            // I'm going to leave this for now and worry about it later when I migrate to .NET Core and
            // switch to using the SixLabors image library.
            UniversalBitmap.DrawingSession session = (UniversalBitmap.DrawingSession)sessionObj;
            if (x < 0 || y < 0 || x >= session.Bitmap.Width || y >= session.Bitmap.Height) return true;
            session.Flush();
            session.Bitmap.SetPixel(x, y, r, g, b, a);
            session.ReInitializeHack();
            return false;
        }

        public static bool FromBytes(int[] bytesAsInts, int[] sizeOut, object[] nativeDataOut)
        {
            UniversalBitmap bmp = new UniversalBitmap(bytesAsInts.Select(b => (byte)b).ToArray());
            if (!bmp.IsValid)
            {
                nativeDataOut[0] = null;
            }
            else
            {
                sizeOut[0] = bmp.Width;
                sizeOut[1] = bmp.Height;
                nativeDataOut[0] = bmp;
            }
            return true;
        }

        public static object Encode(object bmpObj, int format, bool[] formatOut)
        {
            UniversalBitmap bmp = (UniversalBitmap)bmpObj;
            byte[] bytes;
            switch (format)
            {
                case 1: bytes = bmp.GetBytesAsPng(); break;
                case 2: bytes = bmp.GetBytesAsJpeg(); break;
                default: throw new Exception();
            }
            formatOut[0] = false;
            return bytes.Select(b => (int)b).ToArray();
        }
    }
}

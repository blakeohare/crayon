using System;
using System.Collections.Generic;
using Interpreter.Structs;

namespace Interpreter.Vm
{
    public static class ImageUtil
    {
        public static object NewBitmap(int width, int height)
        {
            return new UniversalBitmap(width, height);
        }

        private static Dictionary<int, UniversalBitmap> loadedChunks = new Dictionary<int, UniversalBitmap>();
        public static void ChunkLoadAsync(int chunkId, int[] chunkIds, Value loadedCallback)
        {
            loadedChunks[chunkId] = ResourceReader.ReadImageResource("ch_" + chunkId + ".png");
            int total = chunkIds.Length;
            int loaded = 0;
            foreach (int otherChunk in chunkIds)
            {
                if (loadedChunks.ContainsKey(otherChunk)) loaded++;
            }
            EventLoop.ExecuteFunctionPointerNativeArgs(loadedCallback, new object[] { chunkId, loaded, total });
        }

        public static object GetChunk(int chunkId)
        {
            return loadedChunks[chunkId];
        }

        public static object Scale(object rawBmp, int newWidth, int newHeight, int algo)
        {
            if (algo != 1) throw new NotImplementedException();
            UniversalBitmap bmp = (UniversalBitmap)rawBmp;
            int oldWidth = bmp.Width;
            int oldHeight = bmp.Height;

            if (oldWidth == newWidth && oldHeight == newHeight)
            {
                // Scale is used for 1:1 cloning
                UniversalBitmap clone = new UniversalBitmap(newWidth, newHeight);
                clone.GetActiveDrawingSession().Draw(bmp, 0, 0, 0, 0, newWidth, newHeight).Flush();
                return clone;
            }

            throw new NotImplementedException();
        }

        public static object StartEditSession(object bmpObj)
        {
            UniversalBitmap bmp = (UniversalBitmap)bmpObj;
            UniversalBitmap.DrawingSession session = bmp.GetActiveDrawingSession();
            return session;
        }

        public static void EndEditSession(object sessionObj, object bmpObj)
        {
            UniversalBitmap.DrawingSession session = (UniversalBitmap.DrawingSession)sessionObj;
            session.Flush();
        }

        public static void Blit(object targetObj, object srcObj, int tx, int ty, int tw, int th, int sx, int sy, int sw, int sh)
        {
            UniversalBitmap.DrawingSession target = (UniversalBitmap.DrawingSession)targetObj;
            UniversalBitmap src = (UniversalBitmap)srcObj;
            if (tw != sw || th != sh) throw new NotImplementedException();
            target.Draw(src, tx, ty, sx, sy, tw, th);
        }

        public static void GetPixel(object bmpRaw, object nullableEditSession, int x, int y, int[] colorOut)
        {
            UniversalBitmap bmp = (UniversalBitmap)bmpRaw;
            if (x < 0 || y < 0 || x >= bmp.Width || y >= bmp.Height)
            {
                colorOut[4] = 0;
                return;
            }
            colorOut[4] = 1;
            bmp.GetPixel(x, y, colorOut);
            return;
        }

        // returns true for out of range
        public static bool SetPixel(object session, int x, int y, int r, int g, int b, int a)
        {
            throw new NotImplementedException();
        }
    }
}

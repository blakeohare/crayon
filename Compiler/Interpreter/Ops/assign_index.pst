
valueStackSize -= 3;
value = valueStack[valueStackSize + 2]; // value
value2 = valueStack[valueStackSize + 1]; // index
root = valueStack[valueStackSize];

type = root.type;
bool1 = row[0] == 1; // re-push this onto the stack once it is assigned
if (type == Types.LIST) {
    if (value2.type == Types.INTEGER) {
        i = ((int) value2.internalValue);
        list1 = (List<Value>) root.internalValue;
        if (i >= list1.Size()) {
            hasInterrupt = EX_IndexOutOfRange(ec, "Index is out of range.");
        } else if (i < 0) {
            i += list1.Size();
            if (i < 0) {
                hasInterrupt = EX_IndexOutOfRange(ec, "Index is out of range.");
            } else {
                list1[i] = value;
            }
        } else {
            list1[i] = value;
        }
    } else {
        hasInterrupt = EX_InvalidArgument(ec, "List index must be an integer.");
    }
} else if (type == Types.DICTIONARY) {
    keyType = value2.type;
    if (keyType == Types.INTEGER) {
        intKey = (int) value2.internalValue;
    } else if (keyType == Types.STRING) {
        stringKey = (string) value2.internalValue;
    } else if (keyType == Types.INSTANCE) {
        objInstance1 = (ObjectInstance) value2.internalValue;
        intKey = objInstance1.objectId;
    } else {
        hasInterrupt = EX_InvalidArgument(ec, "Invalid key for a dictionary.");
    }

    if (!hasInterrupt) {
        dictImpl = (DictImpl) root.internalValue;
        bool2 = dictImpl.size > 0; // already contains stuff
        if (bool2 && dictImpl.keyType != keyType) {
            hasInterrupt = EX_InvalidKey(ec, "Cannot have multiple keys in one dictionary with different types.");
        } else if (keyType == Types.STRING) {
            int1 = dictImpl.stringToIndex.TryGet(stringKey, -1);
            if (int1 == -1) {
                dictImpl.stringToIndex[stringKey] = dictImpl.size;
                dictImpl.size += 1;
                dictImpl.keys.Add(value2);
                dictImpl.values.Add(value);
                if (!bool2) { // is empty?
                    dictImpl.keyType = keyType;
                }
            } else {
                dictImpl.values[int1] = value;
            }
        } else {
            int1 = dictImpl.intToIndex.TryGet(intKey, -1);
            if (int1 == -1) {
                dictImpl.intToIndex[intKey] = dictImpl.size;
                dictImpl.size += 1;
                dictImpl.keys.Add(value2);
                dictImpl.values.Add(value);
                if (!bool2) { // is empty?
                    dictImpl.keyType = keyType;
                }
            } else {
                dictImpl.values[int1] = value;
            }
        }
    }
} else {
    hasInterrupt = EX_UnsupportedOperation(ec, Core.StringConcatAll(getTypeFromId(type), " type does not support assigning to an index."));
}

// This shouldn't hurt even when there's an interrupt.
if (bool1) {
    // No capacity check necessary. Things were already popped off.
    valueStack[valueStackSize] = value;
    valueStackSize += 1;
}

/*
    row[0] -> min args
    row[1] -> max args
    row[2] -> scope size
    row[3] -> function code length
    row[4] -> number of optional args
        row[4 + n] -> optional jump length
    row[next] -> number of closure IDs
        row[next + n] -> closure ID
*/

// Initialize the Lambda if it isn't already.
// TODO: move this into the metadata initializer
if (!p.lambdaTable.Contains(pc)) {
    int1 = 4 + row[4] + 1;
    len = row[int1];
    intArray1 = new Array<int>(len);
    for (i = 0 ; i < len; i += 1) {
        intArray1[i] = row[int1 + i + 1];
    }
    p.lambdaTable[pc] = new LambdaInfo(pc, intArray1, row[2], row[0], row[1]);
}

closure = new Dictionary<int, ClosureValuePointer>();
parentClosure = stack.closureVariables;
if (parentClosure == null) {
    parentClosure = new Dictionary<int, ClosureValuePointer>();
    stack.closureVariables = parentClosure;
}

lambdaInfo = p.lambdaTable[pc];
intArray1 = lambdaInfo.closureIds;
len = intArray1.Size();

for (i = 0; i < len; i += 1) {
    j = intArray1[i];
    if (parentClosure.Contains(j)) {
        closure[j] = parentClosure[j];
    } else {
        closure[j] = new ClosureValuePointer(null);
        parentClosure[j] = closure[j];
    }
}

@import("ValueStackCapacityCheck.pst");
valueStack[valueStackSize] = new Value(
    Types.FUNCTION,
    new FunctionPointer(FunctionPointerType.LAMBDA, null, 0, pc, closure));
valueStackSize += 1;

pc += row[3]; // skip over the actual function body, which is inlined below the LAMBDA op.

C$common = 1;
C$common$textResources = {};
C$common$programData = null;
C$common$resources = {};
C$common$binaryResources = {};
C$common$libraryFunctionLookups = {};
C$common$envDescriptor = () => 'web|javascript';
C$common$globalOptions = {};
C$common$globalOptions['fullscreen'] = false;

// overridden by resources.js if present.
C$common$jsFilePrefix = '';
C$common$imageManifest = '';

function main() {
	C$common$programData = createVm(C$bytecode, C$common$resourceManifest, C$common$imageManifest);
	vmEnableLibStackTrace(C$common$programData);
	C$handleVmResult(startVm(C$common$programData));
}

function C$runInterpreter(execId) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreter(vm, execId));
}

function C$runInterpreterWithFunctionPointer(fp, args) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreterWithFunctionPointer(vm, fp, args));
}

let C$convertNativeArgToValue = value => {
	let globals = vmGetGlobals(C$common$programData);
	if (value === null || value === undefined) return buildNull(globals);
	if (value === true || value === false) return buildBoolean(globals, value);
	switch (typeof(value)) {
		case 'string': return buildString(globals, value);
		case 'number': return value % 1 === 0 ? buildInteger(globals, value) : buildFloat(globals, value);
		case 'object':
			if (Array.isArray(value)) {
				let arr = [];
				for (let item of value) {
					arr.push(C$convertNativeArgToValue(item));
				}
				return buildList(arr);
			}
			let keys = Object.keys(value);
			let values = keys.map(k => C$convertNativeArgToValue(value[k]));
			return buildStringDictionary(globals, keys, values);
		default: return buildNull(globals);
	}
};

function C$runInterpreterWithFunctionPointerNativeArgs(fp, args) {
	return C$runInterpreterWithFunctionPointer(fp, args.map(C$convertNativeArgToValue));
}

function C$handleVmResult(res) {
	var vm = C$common$programData;
	var status = getVmResultStatus(res);
	while (status == 5 || status == 6) { // REINVOKE || LOAD_ASSEMBLY
		if (status == 5) {
			var delayMillis = Math.floor(1000 * getVmReinvokeDelay(res));
			var execId = getVmResultExecId(res);
			window.setTimeout(function() { C$runInterpreter(execId); }, delayMillis);
			return;
		} else {
			var parts = getVmResultAssemblyInfo(res).split(',');
			var name = parts[0];
			var version = parts[1];
			var startupFunc = parts[2];
			C$loadAssembly(name, version, startupFunc);
		}
		res = runInterpreter(vm, getVmResultExecId(res))
		status = getVmResultStatus(res);
	}

	if (status == 1 || status == 2 || status == 3) return;

	throw "Unknown status";
}

C$loadAssembly = function(name, ver, startupFn) {
	if (startupFn.length > 0) {
		var fn = window[startupFn];
		if (fn !== undefined) {
			fn(C$common$programData, []);
		}
	}
};

C$common$readResourceText = function (path) {
	var v = C$common$getTextRes(path);
	return !v ? null : v;
};

C$common$alwaysTrue = function () { return true; };
C$common$alwaysFalse = function () { return false; };

C$common$addTextRes = function (path, value) {
	C$common$textResources[path] = value;
};

C$common$getTextRes = function (path) {
	return C$common$textResources[path];
};

C$common$addBinaryRes = function (path, value) {
	C$common$binaryResources[path] = value;
};

C$common$getBinaryResBase64 = function (path) {
	return C$common$binaryResources[path];
};

C$common$print = function (value) {
	console.log(value);
};

C$common$scrapeLibFuncNames = function(libname) {
	var prefix = 'lib_' + libname + '_function_';
	var functions = {};
	for (var key in window) {
		if (key.indexOf(prefix) === 0) {
			var name = key.substring(prefix.length, key.length + prefix.length);
			functions[name] = window[key];
		}
	}
	C$common$libraryFunctionLookups[libname] = functions;
};

C$common$getFunction = function(name) {
	var p = name.split(',');
	var check = p[p.length - 1];
	if (window[check] !== undefined) {
		return window[check];
	}
	return null;
};

LIB$datetime$utcTimeZone = {
	name: "utc",
	isLocal: false,
	observesDst: false
};

LIB$datetime$extractTimeZone = function(nullableTz) {
	if (nullableTz === null) return LIB$datetime$utcTimeZone;
	return nullableTz;
};

LIB$datetime$getDataForLocalTimeZone = function(strOut, intOut) {
	var name = Intl.DateTimeFormat().resolvedOptions().timeZone;
	strOut[0] = name;
	strOut[1] = name;
	intOut[0] = -1; // TODO: remove this
	var now = new Date();
	var janSeconds = new Date(now.getFullYear(), 1, 1, 0, 0, 0).getTime() / 1000;
	var junSeconds = new Date(now.getFullYear(), 6, 1, 0, 0, 0).getTime() / 1000;
	var janToJunHours = (junSeconds - janSeconds) / 3600;
	var dstOccurs = (janToJunHours % 24) != 0;
	intOut[1] = dstOccurs ? 1 : 0;
	return {
		name: name,
		isLocal: true,
		observesDst: dstOccurs
	};
};

LIB$datetime$unixToStructured = function(intOut, nullableTimeZone, unixTime) {
	var unixTimeInt = Math.floor(unixTime);
	var micros = Math.floor(1000000 * (unixTime - unixTimeInt));
	var millis = Math.floor(micros / 1000);
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	var d = new Date(Math.floor(unixTime * 1000));
	intOut[6] = millis;
	intOut[7] = micros;
	if (tz.isLocal) {
		intOut[0] = d.getFullYear();
		intOut[1] = d.getMonth() + 1;
		intOut[2] = d.getDate();
		intOut[3] = d.getHours();
		intOut[4] = d.getMinutes();
		intOut[5] = d.getSeconds();
		intOut[8] = d.getDay() + 1;
	} else {
		var p = d.toISOString().split('Z')[0].split('T');
		var pd = p[0].split('-');
		var pt = p[1].split('.')[0].split(':');
		
		intOut[0] = parseInt(pd[0]);
		intOut[1] = parseInt(pd[1]);
		intOut[2] = parseInt(pd[2]);
		intOut[3] = parseInt(pt[0]);
		intOut[4] = parseInt(pt[1]);
		intOut[5] = parseInt(pt[2]);
		intOut[8] = new Date(intOut[0], intOut[1] - 1, intOut[2], 12, 0, 0).getDay() + 1;
	}
	return true;
};

LIB$datetime$pad = function(n, length) {
	n = n + '';
	while (n.length < length) {
		n = '0' + n;
	}
	return n;
};
LIB$datetime$parseDate = function(intOut, nullableTimeZone, year, month, day, hour, minute, microseconds) {
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	intOut[2] = microseconds % 1000000;
	intOut[0] = 1;
	var seconds = Math.floor((microseconds - intOut[2]) / 1000000);
	if (tz.isLocal) {
		var d = new Date(year, month - 1, day, hour, minute, seconds);
		intOut[1] = Math.floor(d.getTime() / 1000);
	} else {
		intOut[1] = new Date([
			year, "-",
			LIB$datetime$pad(month, 2), "-",
			LIB$datetime$pad(day, 2), "T",
			LIB$datetime$pad(hour, 2), ":",
			LIB$datetime$pad(minute, 2), ":",
			LIB$datetime$pad(seconds, 2), "Z"].join('')).getTime();
	}
};

LIB$datetime$getUtcOffsetAt = function(tz, unixTime) {
	var d = new Date(Math.floor(unixTime * 1000));
	return -60 * d.getTimezoneOffset();
};

C$interop$getInteropObj = () => {
	if (!window.CrayonInterop) window.CrayonInterop = {};
	return window.CrayonInterop;
};

C$interop$invoke = (fnName, argsStr, cbValue) => {
	let fn = C$interop$getInteropObj()[fnName];
	if (!fn) return false;
	let args = JSON.parse(argsStr).args;
	setTimeout(() => {
		let result = fn.apply(null, args);
		if (cbValue !== null) {
			Promise.resolve(result).then(value => {
				let valueStr = JSON.stringify({ value });
				C$runInterpreterWithFunctionPointerNativeArgs(cbValue, [valueStr]);
			});
		}
	}, 0);
	return true;
};

C$interop$callbacksById = {};

C$interop$registerCallback = (funcName, useReturn, funcValue) => {
	let ci = C$interop$getInteropObj();
	if (!ci.INTERNAL_ID_ALLOC) ci.INTERNAL_ID_ALLOC = 0;
	ci[funcName] = function() {
		let args = [];
		for (let i = 0; i < arguments.length; ++i) {
			args.push(arguments[i]);
		}
		let argStr = JSON.stringify({ args });
		let id = 0;
		let resolve = null;
		let p = null;
		if (useReturn) {
			p = new Promise(res => {resolve = res; });
			id = ++ci.INTERNAL_ID_ALLOC;
			C$interop$callbacksById[id] = resolve;
		} else {
			p = Promise.resolve(null);
		}
		setTimeout(() => {
			C$runInterpreterWithFunctionPointerNativeArgs(funcValue, [id, argStr]);
		}, 0);
		
		return p;
	};
};

C$interop$callbackReturn = (id, valueStr) => {
	if (id === 0) return;
	let fn = C$interop$callbacksById[id];
	delete C$interop$callbacksById[id];
	let retVal = JSON.parse(valueStr).value;
	fn(retVal);
};

C$http$send = (cb, failCb, url, method, contentType, binaryContent, textContent, headersKvp, bytesObj, bytesObjNativeData) => {
	let req = new XMLHttpRequest();
	
	req.onload = (e, e2) => {
		let headers = [];
		let ct = '';
		for (let rawHeader of req.getAllResponseHeaders().trim().split('\r\n')) {
			let t = rawHeader.split(':', 2);
			let name = t[0].trim();
			let value = t.length > 1 ? t[1].trim() : '';
			headers.push(name);
			headers.push(value);
			if (name.toLowerCase() == 'content-type') ct = value;
		}
		
		req.response.arrayBuffer().then(buf => {
			let nd = [];
			let arr = new Uint8Array(buf);
			let bl = arr.length;
			for (let i = 0; i < bl; ++i) {
				nd.push(arr[i]);
			}
			bytesObjNativeData[0] = nd;
			
			let text = null;
			try {
				text = new TextDecoder().decode(arr);
			} catch (_) { }
			
			C$runInterpreterWithFunctionPointer(cb, [
				C$convertNativeArgToValue(req.status),
				C$convertNativeArgToValue(req.statusText),
				C$convertNativeArgToValue(ct),
				C$convertNativeArgToValue(headers),
				bytesObj,
				C$convertNativeArgToValue(text)
			]);
		});
	};
	
	req.onerror = (e1, e2) => {
		C$runInterpreterWithFunctionPointer(failCb, []);
	};
	
	req.open(method, url, true);
	req.responseType = 'blob';
	
	for (let i = 0; i < headersKvp.length; i += 2) {
		let n = headersKvp[i];
		let v = headersKvp[i + 1];
		switch (n.toLowerCase()) {
			// These are forbidden by the browser.
			case 'content-type':
			case 'content-length':
			case 'user-agent':
				break;
			default:
				req.setRequestHeader(n, v);
				break;
		}
	}
	
	if (textContent !== null) {
		req.send(textContent);
	} else if (binaryContent !== null) {
		req.send(Int8Array.from(binaryContent));
	} else {
		req.send(null);
	}
};

let C$ImageUtil$canvasByChunkId = {};
C$ImageUtil$getChunk = cid => {
	return C$ImageUtil$canvasByChunkId[cid] || null;
};

C$ImageUtil$chunkLoadAsync = (chunkId, chunkIds, cb) => {
	let path = C$common$jsFilePrefix + 'resources/images/ch_' + chunkId + '.png';
	let loader = new Image();
	loader.onload = () => {
		let canvas = document.createElement('canvas');
		canvas.width = loader.width;
		canvas.height = loader.height;
		let ctx = canvas.getContext('2d');
		ctx.drawImage(loader, 0, 0);
		C$ImageUtil$canvasByChunkId[chunkId] = { canvas, ctx, b64: null };
		let total = chunkIds.length;
		let loaded = chunkIds.filter(id => C$ImageUtil$canvasByChunkId[id]).length;
		setTimeout(() => C$runInterpreterWithFunctionPointerNativeArgs(cb, [chunkId, loaded, total]), 0);
	};
	loader.src = path;
};

C$ImageUtil$scale = (bmp, w, h, algo) => {
	if (algo !== 1) throw new Error();
	let canvas = document.createElement('canvas');
	canvas.width = w;
	canvas.height = h;
	let ctx = canvas.getContext('2d');
	ctx.drawImage(bmp.canvas, 0, 0, w, h);
	return { canvas, ctx, b64: null };
};

C$ImageUtil$newBitmap = (w, h) => {
	let cnv = document.createElement('canvas');
	cnv.width = w;
	cnv.height = h;
	return {
		canvas: cnv,
		ctx: cnv.getContext('2d'),
		b64: null,
	};
};

C$ImageUtil$fromBytes = (data, szOut, ndOut, cb) => {
	if (data.length < 2) return null;
	let isPng = data.substr(0, 2) == 'iV';
	let loader = new Image();
	loader.onload = () => {
		let cnv = document.createElement('canvas');
		let [w, h] = [loader.width, loader.height];
		cnv.width = w;
		cnv.height = h;
		let ctx = cnv.getContext('2d');
		ctx.drawImage(loader, 0, 0);
		ndOut[0] = {
			canvas: cnv,
			ctx,
			b64: data,
		};
		C$runInterpreterWithFunctionPointerNativeArgs(cb, [0, w, h]);
	};
	loader.onerror = () => {
		C$runInterpreterWithFunctionPointerNativeArgs(cb, [2, 0, 0]);
	};
	loader.src = ('data:image/' + (isPng ? 'png' : 'jpeg') + ';base64,') + data;
	return false;
};

C$ImageUtil$getPixel = (bmp, optEdit, x, y, cOut) => {
	let img = bmp;
	if (optEdit !== null) {
		img = optEdit;
	}
	let c = img.canvas;
	let w = c.width;
	let h = c.height;
	if (x < 0 || y < 0 || x >= w || y >= h) {
		cOut[4] = 0;
		return;
	}
	cOut[4] = 1;
	let px = bmp.ctx.getImageData(x, y, 1, 1).data;
	cOut[0] = px[0];
	cOut[1] = px[1];
	cOut[2] = px[2];
	cOut[3] = px[3];
};

C$ImageUtil$singlePixelImgData = null;
C$hexLookup = (() => {
	let o = [];
	let H = '0123456789abcdef'.split('');
	for (let a of H) for (let b of H) {
		o.push(a + b);
	}
	return o;
})();
C$hexLookupHash = C$hexLookup.map(_ => '#' + _);

C$ImageUtil$setPixel = (session, x1, y1, x2, y2, r, g, b, a) => {
	let w = session.width;
	let h = session.height;
	if (x1 < 0 || y1 < 0 || x1 >= w || y1 >= h || x2 < 0 || y2 < 0 || x2 >= w || y2 >= h) return true;
	let ctx = session.ctx;
	if (a == 255) {
		ctx.fillStyle = C$hexLookupHash[r] + C$hexLookup[g] + C$hexLookup[b];
		if (x1 == x2 && y1 == y2) {
			ctx.fillRect(x1, y1, 1, 1);
		} else {
			let x = Math.min(x1, x2);
			let y = Math.min(y1, y2);
			w = Math.abs(x1 - x2) + 1;
			h = Math.abs(y1 - y2) + 1;
			ctx.fillRect(x, y, w, h);
		}
	} else {
		if (C$ImageUtil$singlePixelImgData === null) {
			C$ImageUtil$singlePixelImgData = session.ctx.getImageData(x1, y1, 1, 1);
		}
		let d = C$ImageUtil$singlePixelImgData.data;
		d[0] = r;
		d[1] = g;
		d[2] = b;
		d[3] = a;

		if (x1 == x2 && y1 == y2) {
			session.ctx.putImageData(C$ImageUtil$singlePixelImgData, x1, y1);
		} else {
			let xLeft = Math.min(x1, x2);
			let yTop = Math.min(y1, y2);
			let xRight = Math.max(x1, x2);
			let yBottom = Math.max(y1, y2);
			for (let y = yTop; y <= yBottom; ++y) {
				for (let x = xLeft; x <= xRight; ++x) {
					session.ctx.putImageData(C$ImageUtil$singlePixelImgData, x, y);
				}
			}
		}
	}
	return false;
};

C$ImageUtil$startEditSession = bmp => {
	let canvas = document.createElement('canvas');
	canvas.width = bmp.canvas.width;
	canvas.height = bmp.canvas.height;
	let ctx = canvas.getContext('2d');
	ctx.drawImage(bmp.canvas, 0, 0);
	return {
		width: canvas.width,
		height: canvas.height,
		canvas,
		ctx,
		parent: bmp,
	};
};

C$ImageUtil$endEditSession = (session, bmp) => {
	bmp.canvas = session.canvas;
	bmp.ctx = session.ctx;
	bmp.b64 = null;
	session.canvas = null;
	session.ctx = null;
};

C$ImageUtil$encode = (bmp, format, formatOut) => {
	let d = bmp.canvas.toDataURL(format == 1 ? 'image/png' : 'image/jpeg');
	let b64 = d.split(',')[1];
	formatOut[0] = true;
	return b64;
};

C$ImageUtil$blit = (target, src, sx, sy, sw, sh, tx, ty, tw, th) => {
	if (tw === sw && th === sh && sx == 0 && sy === 0) {
		target.ctx.drawImage(src.canvas, tx, ty);
	} else {
		throw new Error("Sorry, not implemented quite yet.");
	}
};

let C$textEncoding = (() => {

let bytesToText = (bytes, format, strOut) => {
	var i;
	var length = bytes.length;
	var sb = [];
	var a;
	var b;
	var c;
	var cp;
	var t;
	var isBigEndian = format == 5 || format == 7;
	switch (format) {
		case 1:
		case 2:
			var isAscii = format == 1;
			for (i = 0; i < length; ++i) {
				c = bytes[i];
				if (isAscii && c > 127) return 1;
				sb.push(String.fromCharCode(c));
			}
			break;
		case 3:
			i = 0;
			while (i < length) {
				c = bytes[i];
				if ((c & 0x80) == 0) {
					cp = c;
					i++;
				} else if ((c & 0xE0) == 0xC0) {
					if (i + 1 >= length) return 1;
					cp = c & 0x1FF;
					c = bytes[i + 1];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					i += 2;
				} else if ((c & 0xF0) == 0xE0) {
					if (i + 2 >= length) return 1;
					cp = c & 0x0F;
					c = bytes[i + 1];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					c = bytes[i + 2];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					i += 3;
				} else if ((c & 0xF8) == 0xF0) {
					if (i + 3 >= length) return 1;
					cp = c & 0x07;
					c = bytes[i + 1];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					c = bytes[i + 2];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					c = bytes[i + 3];
					if ((c & 0xC0) != 0x80) return 1;
					cp = (cp << 6) | (c & 0x3F);
					i += 4;
				}
				sb.push(String.fromCodePoint(cp));
			}
			break;
		
		case 4:
		case 5:
			for (i = 0; i < length; i += 2) {
				if (isBigEndian) {
					a = bytes[i];
					b = bytes[i + 1];
				} else {
					a = bytes[i + 1];
					b = bytes[i];
				}
				c = (a << 8) | b;
				if (c < 0xD800 || c > 0xDFFF) {
					cp = c;
				} else if (c < 0xD800 && c >= 0xDC00) {
					return 1;
				} else if (i + 3 >= length) {
					return 1;
				} else {
					if (isBigEndian) {
						a = bytes[i + 2];
						b = bytes[i + 3];
					} else {
						a = bytes[i + 3];
						b = bytes[i + 2];
					}
					b = (a << 8) | b;
					a = c;
					// a and b are now 16 bit words
					if (b < 0xDC00 || b > 0xDFFF) return 1;
					cp = (((a & 0x03FF) << 10) | (b & 0x03FF)) + 0x10000;
					i += 2;
				}
				sb.push(String.fromCodePoint(cp));
			}
			break;
		
		case 6:
		case 7:
			for (i = 0; i < length; i += 4) {
				if (isBigEndian) {
					cp = bytes[i + 3] | (bytes[i + 2] << 8) | (bytes[i + 1] << 16) | (bytes[i] << 24);
				} else {
					cp = bytes[i] | (bytes[i + 1] << 8) | (bytes[i + 2] << 16) | (bytes[i + 3] << 24);
				}
				sb.push(String.fromCodePoint(cp));
			}
			break;
	}
	
	strOut[0] = sb.join('');
	return 0;
};

let stringToCodePointList = (s) => {
	var codePoints = Array.from(s);
	var length = codePoints.length;
	var n;
	for (var i = 0; i < length; ++i) {
		n = codePoints[i].codePointAt(0);
		codePoints[i] = n;
	}
	return codePoints;
};

let textToBytes = (value, includeBom, format, byteList, positiveIntegers, intOut) => {
	intOut[0] = 0;
	var codePoints = stringToCodePointList(value);
	var length = codePoints.length;
	var maxValue = 0;
	var n = 0;
	var i;
	for (i = 0; i < length; ++i) {
		if (codePoints[i] > maxValue) {
			maxValue = codePoints[i];
		}
	}
	if (maxValue > 127 && format == 1) return 1;

	// TODO: this is slightly wrong. Unicode characters should be converted into extended ASCII chars, if possible.
	if (maxValue > 255 && format == 2) return 1;

	var bytes;
	if (format <= 2) {
		bytes = codePoints;
	} else {
		bytes = [];
		if (includeBom) {
			switch (format) {
				case 3: bytes = [239, 187, 191]; break;
				case 4: bytes = [255, 254]; break;
				case 5: bytes = [254, 255]; break;
				case 6: bytes = [255, 254, 0, 0]; break;
				case 7: bytes = [0, 0, 254, 255]; break;
			}
		}
		length = codePoints.length;
		switch (format) {
			case 3:
				codePointsToUtf8(codePoints, bytes);
				break;
			case 4:
			case 5:
				codePointsToUtf16(codePoints, bytes, format == 5);
				break;
			case 6:
			case 7:
				codePointsToUtf32(codePoints, bytes, format == 7);
				break;
		}
	}
	
	for (i = 0; i < bytes.length; ++i) {
		byteList.push(positiveIntegers[bytes[i]]);
	}
	
	return 0;
};

let codePointsToUtf8 = (points, buffer) => {
	var length = points.length;
	var p;
	for (var pIndex = 0; pIndex < length; ++pIndex) {
		p = points[pIndex];
		if (p < 0x80) {
			buffer.push(p);
		} else if (p < 0x0800) {
			buffer.push(0xC0 | ((p >> 6) & 0x1F));
			buffer.push(0x80 | (p & 0x3F));
		} else if (p < 0x10000) {
			buffer.push(0xE0 | ((p >> 12) & 0x0F));
			buffer.push(0x80 | ((p >> 6) & 0x3F));
			buffer.push(0x80 | (p & 0x3F));
		} else {
			buffer.push(0xF0 | ((p >> 18) & 3));
			buffer.push(0x80 | ((p >> 12) & 0x3F));
			buffer.push(0x80 | ((p >> 6) & 0x3F));
			buffer.push(0x80 | (p & 0x3F));
		}
	}
};

let codePointsToUtf16 = (points, buffer, isBigEndian) => {
	var length = points.length;
	var p;
	var a;
	var b;
	
	for (var pIndex = 0; pIndex < length; ++pIndex) {
		p = points[pIndex];
		if (p < 0x10000) {
			if (isBigEndian) {
				buffer.push((p >> 8) & 255);
				buffer.push(p & 255);
			} else {
				buffer.push(p & 255);
				buffer.push((p >> 8) & 255);
			}
		} else {
			p -= 0x10000;
			a = 0xD800 | ((p >> 10) & 0x03FF);
			b = 0xDC00 | (p & 0x03FF);
			if (isBigEndian) {
				buffer.push((a >> 8) & 255);
				buffer.push(a & 255);
				buffer.push((b >> 8) & 255);
				buffer.push(b & 255);
			} else {
				buffer.push(a & 255);
				buffer.push((a >> 8) & 255);
				buffer.push(b & 255);
				buffer.push((b >> 8) & 255);
			}
		}
	}
};

let codePointsToUtf32 = (points, buffer, isBigEndian) => {
	var i = 0;
	var length = points.length;
	var p;
	while (i < length) {
		p = points[i++];
		if (isBigEndian) {
			buffer.push((p >> 24) & 255);
			buffer.push((p >> 16) & 255);
			buffer.push((p >> 8) & 255);
			buffer.push(p & 255);
		} else {
			buffer.push(p & 255);
			buffer.push((p >> 8) & 255);
			buffer.push((p >> 16) & 255);
			buffer.push((p >> 24) & 255);
		}
	}
};

return {
	textToBytes,
	bytesToText,
};

})();

let C$common$parseJson = (() => {

let convert = (g, v) => {
	switch (getType(v)) {
		case 'N': return buildNull(g);
		case 'B': return buildBoolean(g, v);
		case 'I': return buildInteger(g, v);
		case 'F': return buildFloat(g, v);
		case 'S': return buildString(g, v);
		case 'L':
			let list = [];
			for (let m of v) list.push(convert(g, m));
			return buildList(list);
		case 'O':
			let keys = Object.keys(v);
			let values = [];
			for (let k of keys) values.push(convert(g, v[k]));
			return buildStringDictionary(g, keys, values);
		default: return buildNull(g);
	}
};

let getType = (t) => {
	if (typeof t == "string") return 'S';
	if (!t) return t === false ? 'B' : 'N';
	if (t === true) return 'B';
	if (typeof t == "number") return (t % 1 == 0) ? 'I' : 'F';
	if (typeof t == 'object') return Array.isArray(t) ? 'L' : 'O';
	return 'null';
};

return (globals, txt) => {
	try {
		return convert(globals, JSON.parse(txt));
	} catch (e) {
		return null;
	}
};
})();

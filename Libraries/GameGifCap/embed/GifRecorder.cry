import Game;
import Math;

/*
    GifRecorder has a list of sessions.
    When record() is invoked, the frame end handler is added to the GameWindow (but only once)
    It also creates a GifRecSession.
    When a GifRecSession is created, it reigsters itself in a global
*/

namespace GameGifCap {

    class GifRecorder {

        static field _registered = false;

        field _sessions = [];
        field _fps;

        constructor(fps) {
            if (fps > 1000) fps = 1000;
            else if (fps < .01) throw new InvalidArgumentException("Invalid FPS");

            this._fps = fps;

        }

        function isRecording() {
            return this._sessions.length > 0 && this._sessions[-1]._isRecording;
        }

        function record() {
            if (!GifRecorder._registered) {
                GifRecorder._registered = true;
                Game.GameWindow._frameEndHandlers.add(GameGifCap.gameFrameEndCallback);
            }
            this._sessions.add(new GifRecSession());
        }

        function pause() {
            if (this._sessions.length > 0) {
                this._sessions[-1]._isRecording = false;
            }
        }

        function save(path) {
            // TODO: verify path
            path = path + '';
            images = [];
            for (session : this._sessions) {
                images.concat(session._images);
            }
            $$lib_gamegifcap_saveToDisk(path, images, Math.floor(1000 / this._fps));
        }

        function clear() {
            this._sessions.clear();
        }
    }

    function gameFrameEndCallback() {
        deadSessions = null;
        for (session : GifRecSession.activeSessions.keys()) {
            if (session._isRecording) {
                session.cap();
            } else {
                if (deadSessions == null) deadSessions = [];
                deadSessions.add(session);
            }
        }
        if (deadSessions != null) {
            for (ds : deadSessions) {
                GifRecSession.activeSessions.remove(ds);
            }
        }
    }

    class GifRecSession {

        static field activeSessions = {};

        field _images = [];
        field _isRecording = true;

        constructor() {
            $$$('allocNativeData', this, 1);
            GifRecSession.activeSessions[this] = true;
        }

        function cap() {
            // TODO: invoke screen scraper
            sc = $$lib_gamegifcap_screenCap(this);
            switch (sc) {
                case 0: return;
                case 1: throw new Exception("Game Window not open.");
                default: throw new Exception("Unknown error occurred while capturing the screen.");
            }
        }
    }
}

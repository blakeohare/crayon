using Interpreter.Structs;
using System;
using System.Collections.Generic;

namespace Interpreter.Vm
{
    internal static class CoreFunctions
    {
        public static object[] NamedPipeCreate(string name)
        {
            System.IO.Pipes.NamedPipeClientStream pipe = new System.IO.Pipes.NamedPipeClientStream(name);
            pipe.Connect();
            return new object[] {
                pipe,
                new System.IO.StreamReader(pipe),
                new System.IO.StreamWriter(pipe),
            };
        }

        private static System.IO.StreamWriter GetStreamWriter(object pipeWrapper)
        {
            return (System.IO.StreamWriter)((object[])pipeWrapper)[2];
        }

        private static string NamedPipeConvertErrorMessage(string dotNetError)
        {
            if (dotNetError.StartsWith("Pipe is broken")) return "Pipe is broken.";

            return "An unknown error has occurred.";
        }

        public static string NamedPipeWriteLine(object pipeWrapper, string value)
        {
            try
            {
                GetStreamWriter(pipeWrapper).WriteLine(value);
            }
            catch (System.IO.IOException ioe)
            {
                return NamedPipeConvertErrorMessage(ioe.Message);
            }
            return null;
        }

        public static string NamedPipeFlush(object pipeWrapper)
        {
            try
            {
                GetStreamWriter(pipeWrapper).Flush();
            }
            catch (System.IO.IOException ioe)
            {
                return NamedPipeConvertErrorMessage(ioe.Message);
            }
            return null;
        }

        public static object NamedPipeServerCreate(string name, Value startFn, Value onDataFn, Value closeFn)
        {
            System.IO.Pipes.NamedPipeServerStream namedPipe = new System.IO.Pipes.NamedPipeServerStream(name, System.IO.Pipes.PipeDirection.In);
            System.IO.StreamReader reader = new System.IO.StreamReader(namedPipe);
            object[] output = new object[] { namedPipe, reader, startFn, onDataFn, closeFn };

            System.ComponentModel.BackgroundWorker bgWorker = new System.ComponentModel.BackgroundWorker();
            bgWorker.DoWork += (sender, e) =>
            {
                try
                {
                    namedPipe.WaitForConnection();
                }
                catch (Exception ex)
                {
                    System.Console.WriteLine(ex.Message);
                    return;
                }

                System.Console.WriteLine("Connected, I think.");

                // TODO: this is based on the MessageHub format and needs to be rewritten in a more generic way.
                // Sending individual characters is probably a bad idea performance-wise, and so some sort of
                // batching heuristic needs to be made. This "length@payload" format needs to go into the actual
                // MessageHub code directly.
                int stringLength = 0;
                System.Text.StringBuilder buffer = new System.Text.StringBuilder();
                bool isLengthParsing = true;
                while (true)
                {
                    int b = namedPipe.ReadByte();
                    if (isLengthParsing)
                    {
                        if (b == '@')
                        {
                            stringLength = int.Parse(buffer.ToString());
                            buffer.Clear();
                            if (stringLength == 0)
                            {
                                EventLoop.ExecuteFunctionPointerNativeArgs(onDataFn, new object[] { "" });
                            }
                            else
                            {
                                isLengthParsing = false;
                            }
                        }
                        else
                        {
                            buffer.Append((char)b);
                        }
                    }
                    else
                    {
                        buffer.Append((char)b);
                        stringLength--;
                        if (stringLength == 0)
                        {
                            EventLoop.ExecuteFunctionPointerNativeArgs(onDataFn, new object[] { buffer.ToString() });
                            buffer.Clear();
                            isLengthParsing = true;
                        }
                    }
                }
            };
            bgWorker.RunWorkerAsync();

            return output;
        }

        public static string NamedPipeServerClose(object pipeRaw)
        {
            object[] pipe = (object[])pipeRaw;
            System.IO.Pipes.NamedPipeServerStream namedPipe = (System.IO.Pipes.NamedPipeServerStream)pipe[0];
            namedPipe.Close();
            return null;
        }
    }
}

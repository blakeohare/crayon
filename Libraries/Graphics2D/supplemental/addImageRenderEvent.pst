// There are 13 args. But not all are used. So don't pop them all.

/*
    valueStack[n + 0] -> Draw queue wrapper object.
        nativeData[0] -> event queue
        nativeData[1] -> event queue length
        nativeData[2] -> image queue
        nativeData[3] -> image queue length

    valueStack[n + 1] -> GrahpicsTexture instance

    valueStack[n + 2] -> BIT MASK

    valueStack[n + 3 to 12] -> Copy these directly to the event queue

    GraphicsTexture's nativeData:
        data[0] -> GraphicsTextureResource's native data

        floats:
        data[1] -> texture left
        data[2] -> texture top
        data[3] -> texture right
        data[4] -> texture bottom

        ints:
        data[5] -> pixel width
        data[6] -> pixel height

    GraphicsTextureResource's nativeData:
        data[0] -> bool: is GL based?
        data[1] -> bool: is texture loaded?
        data[2] -> int: GL texture ID
        data[3] -> image resource
        data[4] -> pixel width
        data[5] -> pixel height
*/
Value lib_graphics2d_addImageRenderEvent(Array<Value> args) {
    bool bool1 = false;
    bool bool2 = false;
    double float1 = 0.0;
    int i = 0;
    int int1 = 0;
    int int2 = 0;
    int int3 = 0;
    Array<int> intArray1 = null;
    Array<int> intArray2 = null;
    int len = 0;
    Array<object> objArray1 = null;
    Array<Array<object>> objArrayArray1 = null;
    Array<Array<object>> objArrayArray2 = null;
    ObjectInstance objInstance1 = null;
    ObjectInstance objInstance2 = null;
    Value value = null;
    Value output = VALUE_NULL;
    Value arg1 = args[0];
    Value arg2 = args[1];
    Value arg3 = args[2];
    Value arg4 = args[3];
    Value arg5 = args[4];
    Value arg6 = args[5];
    Value arg7 = args[6];
    Value arg8 = args[7];
    Value arg9 = args[8];
    Value arg10 = args[9];
    Value arg11 = args[10];
    Value arg12 = args[11];
    Value arg13 = args[12];
    objInstance1 = ((ObjectInstance) arg1.internalValue);
    objArray1 = objInstance1.nativeData;

    // Get the event queue, expand it
    intArray1 = ((Array<int>) objArray1[0]);
    len = ((int) objArray1[1]);
    if (len >= intArray1.Size()) {
        intArray2 = new Array<int>(((len * 2) + 16));
        for (i = 0; i < len; i += 1) {
            intArray2[i] = intArray1[i];
        }
        intArray1 = intArray2;
        objArray1[0] = intArray1;
    }
    objArray1[1] = len + 16;

    // Do the same with the image queue. Image queue is not created by the native data int writer, so it may be null.
    objArrayArray1 = ((Array<Array<object>>) objArray1[2]); // image queue
    if (objArrayArray1 == null) {
        int1 = 0;
        objArrayArray1 = new Array<Array<object>>(0);
    } else {
        int1 = ((int) objArray1[3]);
    }
    if (int1 >= objArrayArray1.Size()) {
        objArrayArray2 = new Array<Array<object>>(((int1 * 2) + 16));
        for (i = 0; i < int1; i += 1) {
            objArrayArray2[i] = objArrayArray1[i];
        }
        objArrayArray1 = objArrayArray2;
        objArray1[2] = objArrayArray1;
    }
    objArray1[3] = (int1 + 1);

    // Add the image object's nativeData array to the image queue
    value = arg2; // image instance
    objInstance2 = ((ObjectInstance) value.internalValue);
    objArray1 = objInstance2.nativeData;
    objArrayArray1[int1] = objArray1;

    bool1 = true; // is valid operation
    bool2 = false; // is noop

    // Bit mask
    value = arg3;
    int1 = ((int) value.internalValue);
    intArray1[len] = 6;
    intArray1[(len + 1)] = int1;

    // rotation
    if ((int1 & 4) != 0) {
        value = arg12;
        if (value.type == Types.FLOAT) {
            float1 = ((double) value.internalValue);
        } else {
            if (value.type == Types.INTEGER) {
                float1 = ((int) value.internalValue) + 0.0;
            } else {
                bool1 = false;
            }
        }
        int2 = Core.Int((canonicalizeAngle(float1) * 1048576));
        intArray1[(len | 10)] = int2;
    }

    // alpha
    if (bool1 && ((int1 & 8) != 0)) {
        value = arg13;
        if (value.type == Types.INTEGER) {
            int2 = ((int) value.internalValue);
        } else {
            if (value.type == Types.FLOAT) {
                float1 = ((double) value.internalValue);
                int2 = Core.Int((float1 + 0.5));
            } else {
                bool1 = false;
            }
        }

        if (int2 > 254) {
            // alpha is 255? unset the alpha bit.
            intArray1[(len | 1)] = (int1 - 8);
        } else {
            if (int2 < 0) {
                bool2 = true;
            } else {
                intArray1[(len | 11)] = int2;
            }
        }
    }

    // copy all the numbers
    for (i = 0; i < 8; i += 1) {
        // just blindly copy the rest of the numbers rounding floats to ints
        value = args[(3 + i)];
        if (value.type == Types.INTEGER) {
            int2 = ((int) value.internalValue);
        } else {
            if (value.type == Types.FLOAT) {
                float1 = ((double) value.internalValue);
                int2 = Core.Int((float1 + 0.5));
            } else {
                bool1 = false;
                i = 9;
            }
        }

        intArray1[((len + 2) + i)] = int2;
    }

    // stretching
    if ((int1 & 2) != 0) {
        // target width
        int2 = intArray1[(len + 6)];
        if (int2 < 0) bool1 = false;
        else if (int2 == 0) bool2 = true;

        // target height
        int2 = intArray1[(len + 7)];
        if (int2 < 0) bool1 = false;
        else if (int2 == 0) bool2 = true;
    }

    // slicing
    if ((int1 & 1) != 0) {
        int1 = ((int) objArray1[5]); // image width
        int2 = intArray1[(len + 2)]; // source x
        int3 = intArray1[(len + 4)]; // desired width
        if ((int2 < 0) || ((int2 + int3) > int1) || (int3 < 0)) {
            bool1 = false;
        }
        if (int3 == 0) bool2 = true;

        if (bool1) {
            int1 = ((int) objArray1[6]); // image height
            int2 = intArray1[(len + 3)]; // source y
            int3 = intArray1[(len + 5)]; // desired height
            if ((int2 < 0) || ((int2 + int3) > int1) || (int3 < 0)) {
                bool1 = false;
            }
            if (int3 == 0) bool2 = true;
        }
    }

    if (bool1) {
        if (bool2) {
            // noop (asked for 0 width or height, off-screen, 0 alpha, etc.
            objArray1 = objInstance1.nativeData;
            objArray1[1] = (((int) objArray1[1]) - 16);
            objArray1[3] = (((int) objArray1[3]) - 1);
        }
        output = VALUE_TRUE;
    } else {
        // TODO: this is okay for now since this will cause a crash.
        // however when exceptions become a thing, both queue lengths must be rolled back
        // so that if the exception is caught it won't render invalid data.
        output = VALUE_FALSE;
    }
    return output;
}

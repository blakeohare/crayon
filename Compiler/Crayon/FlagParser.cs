using Exporter;
using System;
using System.Collections.Generic;

namespace Crayon
{
    public class FlagParser
    {
        private static readonly string READABLE_BYTE_CODE = "readablebytecode";
        private static readonly string SHOW_DEP_TREE = "showDepTree";
        private static readonly string SHOW_PERFORMANCE_MARKERS = "showperf";
        private static readonly string BUILD_TARGET = "target";
        private static readonly string BUILD_FILE = "buildfile";
        private static readonly string VM = "vm";
        private static readonly string VM_DIR = "vmdir";
        private static readonly string CBX = "cbx";
        private static readonly string GEN_DEFAULT_PROJ = "genDefaultProj";
        private static readonly string GEN_DEFAULT_PROJ_ES = "genDefaultProjES";
        private static readonly string GEN_DEFAULT_PROJ_JP = "genDefaultProjJP";
        private static readonly string GEN_DEFAULT_PROJ_TYPE = "projType";
        private static readonly string SHOW_LIB_STACK = "showLibStack";
        private static readonly string VERSION = "version";
        private static readonly string APK_EXPORT_PATH = "apkExport";

        private static readonly string RESOURCE_ERRORS_SHOW_RELATIVE_DIR = "resourceErrorsShowRelativeDir";

        // don't use the output directory specified by the build file. Use this arg instead.
        private static readonly string OVERRIDE_OUTPUT_DIR = "overrideOutputDir";

        // don't compile resources or generate byte code. Simply generate compile errors.
        private static readonly string ERROR_CHECK_ONLY = "errorCheckOnly";

        // enable compile time output.
        private static readonly string JSON_OUTPUT = "jsonOutput";

        // Use prefixes for each line of output
        // LIBS: library dependency tree (generated by "-librarydeptree")
        // COMP: compile time information
        // STATUS: give some sort of status change. Options: COMPILE-START, COMPILE-END, RUN-START, RUN-ABORTED, RUN-END
        // STDOUT: standard output
        // STDERR: standard error output
        // STACKTRACE: stack trace information
        private static readonly string USE_OUTPUT_PREFIXES = "useOutputPrefixes";

        // Enable the debugger when running a CBX project.
        private static readonly string DEBUGGER = "Debugger";

        private static readonly HashSet<string> ATOMIC_FLAGS = new HashSet<string>() {
            CBX,
            DEBUGGER,
            ERROR_CHECK_ONLY,
            JSON_OUTPUT,
            SHOW_DEP_TREE,
            READABLE_BYTE_CODE,
            SHOW_LIB_STACK,
            SHOW_PERFORMANCE_MARKERS,
            USE_OUTPUT_PREFIXES,
            RESOURCE_ERRORS_SHOW_RELATIVE_DIR,
            VERSION,
        };

        private static readonly HashSet<string> ONE_ARG_FLAGS = new HashSet<string>()
        {
            BUILD_TARGET,
            BUILD_FILE, // this will be implicitly applied to the first argument that ends in .build and has no flag associated with it.
            APK_EXPORT_PATH,
            OVERRIDE_OUTPUT_DIR,
            VM,
            VM_DIR,

            GEN_DEFAULT_PROJ,
            GEN_DEFAULT_PROJ_ES,
            GEN_DEFAULT_PROJ_JP,
            GEN_DEFAULT_PROJ_TYPE,
        };

        private static readonly Dictionary<string, string> ALIASES = new Dictionary<string, string>()
        {
            { "genDefaultProject", GEN_DEFAULT_PROJ },
            { "genDefaultProjectES", GEN_DEFAULT_PROJ_ES },
            { "genDefaultProjectJP", GEN_DEFAULT_PROJ_JP },
        };

        internal static Command Parse(string[] args, bool isRelease)
        {
            if (isRelease)
            {
                try
                {
                    return ParseImpl(args);
                }
                catch (InvalidOperationException ioe)
                {
                    return new Command
                    {
                        Errors = new Common.Error[] { new Common.Error { Message = ioe.Message } },
                        HasErrors = true,
                    };
                }
            }
            else
            {
                return ParseImpl(args);
            }
        }

        private static Command ParseImpl(string[] args)
        {
            // just short circuit this one since this will only appear without a target project.
            // Otherwise it'll force a CR: prefix
            if (args.Length == 1 && (args[0] == "-v" || args[0] == "--version" || args[0] == "-version"))
            {
                return new Command() { ShowVersion = true };
            }

            Dictionary<string, string> output = new Dictionary<string, string>();
            int i;

            List<string> directRunArgs = new List<string>();

            for (i = 0; i < args.Length; ++i)
            {
                string arg = args[i];
                string dehyphenatedArg = arg.StartsWith("-") ? arg.Substring(1) : "";
                if (arg.StartsWith("-CR:"))
                {
                    string name = arg.Substring("-CR:".Length);
                    if (ATOMIC_FLAGS.Contains(name))
                    {
                        output[name] = "";
                    }
                    else if (ONE_ARG_FLAGS.Contains(name) && i + 1 < args.Length)
                    {
                        string value;
                        if (i + 1 == args.Length || args[i + 1].StartsWith("-CR:"))
                        {
                            value = "";
                        }
                        else
                        {
                            value = args[++i];
                        }
                        output[name] = value;
                    }
                    else
                    {
                        throw new InvalidOperationException("Unrecognized compiler flag: " + name);
                    }
                }
                else if (!output.ContainsKey(BUILD_FILE) && arg.ToLowerInvariant().EndsWith(".build"))
                {
                    output[BUILD_FILE] = arg;
                }
                else if (!output.ContainsKey(BUILD_FILE) || output.ContainsKey(BUILD_TARGET))
                {
                    // don't allow flags without -CR: prefix if a build file has been seen UNLESS a target has also been seen.

                    if (ATOMIC_FLAGS.Contains(dehyphenatedArg))
                    {
                        output[dehyphenatedArg] = "";
                    }
                    else if (ONE_ARG_FLAGS.Contains(dehyphenatedArg))
                    {
                        if (i + 1 < args.Length)
                        {
                            if (args[i].StartsWith("-CR:"))
                            {
                                output[dehyphenatedArg] = "";
                            }
                            else
                            {
                                output[dehyphenatedArg] = args[++i];
                            }
                        }
                        else
                        {
                            output[dehyphenatedArg] = "";
                        }
                    }
                    else
                    {
                        throw new InvalidOperationException("Unknown argument: '" + arg + "'");
                    }
                }
                else if (directRunArgs.Count == 0 && arg == "-target" && i + 1 < args.Length)
                {
                    // Allow -target to be used after the build file without a -CR: prefix IFF it's the
                    // first "-CR:"-free argument after the build file.
                    // This is unfortunate and perhaps the command line arg format should be changed because
                    // it doesn't allow for "-target" to be used as the first command line argument in any
                    // user program if you run directly from the build file.
                    output[BUILD_TARGET] = args[++i];
                }
                else
                {
                    directRunArgs.Add(arg);
                }
            }

            Command command = new Command()
            {
                ShowPerformanceMarkers = output.ContainsKey(SHOW_PERFORMANCE_MARKERS),
                ShowDependencyTree = output.ContainsKey(SHOW_DEP_TREE),
                IsErrorCheckOnly = output.ContainsKey(ERROR_CHECK_ONLY),
                IsJsonOutput = output.ContainsKey(JSON_OUTPUT),
                UseOutputPrefixes = output.ContainsKey(USE_OUTPUT_PREFIXES),
                OutputDirectoryOverride = output.ContainsKey(OVERRIDE_OUTPUT_DIR) ? output[OVERRIDE_OUTPUT_DIR] : null,
                ResourceErrorsShowRelativeDir = output.ContainsKey(RESOURCE_ERRORS_SHOW_RELATIVE_DIR),
            };

            if (output.ContainsKey(BUILD_FILE) && !output.ContainsKey(BUILD_TARGET))
            {
                command.BuildFilePath = output[BUILD_FILE];
                if (output.ContainsKey(CBX))
                {
                    command.IsDirectCbxRun = false;
                    command.CbxExportPath = "";
                }
                else
                {
                    command.IsDirectCbxRun = true;
                    command.DirectRunArgs = directRunArgs.ToArray();
                    command.DirectRunShowLibStack = output.ContainsKey(SHOW_LIB_STACK);
                }

                return command;
            }

            if (directRunArgs.Count > 0)
            {
                throw new InvalidOperationException("Unknown argument: '" + directRunArgs[0] + "'");
            }

            if (output.ContainsKey(GEN_DEFAULT_PROJ_TYPE))
            {
                command.DefaultProjectType = output[GEN_DEFAULT_PROJ_TYPE].Trim().ToLowerInvariant();
            }

            if (output.ContainsKey(GEN_DEFAULT_PROJ))
            {
                command.DefaultProjectId = output[GEN_DEFAULT_PROJ].Trim();
                command.DefaultProjectLocale = "EN";
            }
            else if (output.ContainsKey(GEN_DEFAULT_PROJ_ES))
            {
                command.DefaultProjectId = output[GEN_DEFAULT_PROJ_ES].Trim();
                command.DefaultProjectLocale = "ES";
            }
            else if (output.ContainsKey(GEN_DEFAULT_PROJ_JP))
            {
                command.DefaultProjectId = output[GEN_DEFAULT_PROJ_JP].Trim();
                command.DefaultProjectLocale = "JP";
            }
            else
            {
                if (output.ContainsKey(BUILD_FILE)) command.BuildFilePath = output[BUILD_FILE];
                if (output.ContainsKey(BUILD_TARGET)) command.BuildTarget = output[BUILD_TARGET];
                if (output.ContainsKey(VM_DIR)) command.VmExportDirectory = output[VM_DIR];
                if (output.ContainsKey(APK_EXPORT_PATH)) command.ApkExportPath = output[APK_EXPORT_PATH];
                if (output.ContainsKey(VM)) command.VmPlatform = output[VM];
                if (output.ContainsKey(CBX)) command.CbxExportPath = output[CBX];
                if (output.ContainsKey(VERSION)) command.ShowVersion = true;
            }

            return command;
        }
    }
}

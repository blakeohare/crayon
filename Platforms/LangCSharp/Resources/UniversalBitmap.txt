
namespace Interpreter
{
    public class UniversalBitmap
    {

#if WINDOWS
        private System.Drawing.Bitmap internalBitmap;
#elif OSX
        private readonly Cairo.ImageSurface internalBitmap;
#endif

        private DrawingSession activeDrawingSession = null;
        private BitLockSession activeBitLockSession = null;

        public int Width { get; private set; }
        public int Height { get; private set; }

        private UniversalBitmap() { }

        public UniversalBitmap(byte[] bytes)
        {
#if WINDOWS
            this.internalBitmap = (System.Drawing.Bitmap)System.Drawing.Image.FromStream(new System.IO.MemoryStream(bytes));
            this.Width = this.internalBitmap.Width;
            this.Height = this.internalBitmap.Height;

            if (this.internalBitmap.PixelFormat != System.Drawing.Imaging.PixelFormat.Format32bppArgb)
            {
                System.Drawing.Bitmap newBmp = new System.Drawing.Bitmap(this.Width, this.Height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
                newBmp.SetResolution(this.internalBitmap.HorizontalResolution, this.internalBitmap.VerticalResolution);
                System.Drawing.Graphics g = System.Drawing.Graphics.FromImage(newBmp);
                g.DrawImage(this.internalBitmap, new System.Drawing.PointF(0, 0));
                g.Flush();
                this.internalBitmap = newBmp;
            }
#elif OSX
            this.internalBitmap = GetCairoImageFromBytes(bytes);
            this.Width = this.internalBitmap.Width;
            this.Height = this.internalBitmap.Height;
            if (this.internalBitmap.Format != Cairo.Format.ARGB32)
            {
                UniversalBitmap newBmp = new UniversalBitmap(this.Width, this.Height);
                newBmp.GetActiveDrawingSession().Draw(this, 0, 0, 0, 0, this.Width, this.Height).Flush();
                this.internalBitmap = newBmp.internalBitmap;
            }
#endif
        }

#if OSX
        private static string tmpFileHack = null;
        private static Cairo.ImageSurface GetCairoImageFromBytes(byte[] bytes)
        {
            if (UniversalBitmap.tmpFileHack == null)
            {
                UniversalBitmap.tmpFileHack = System.IO.Path.GetTempFileName();
            }
            // TODO: be more ashamed of this than the current level of shame.
            // Since the only raw image file format decoder I can find in the Cairo library
            // is in the API that takes in a file as a string filepath, this seems to be the
            // only answer. The byte array constructor for ImageSurface is based on decoded
            // image data, not raw PNG or JPEG data.
            System.IO.File.WriteAllBytes(UniversalBitmap.tmpFileHack, bytes);
            Cairo.ImageSurface image = new Cairo.ImageSurface(UniversalBitmap.tmpFileHack);
            System.IO.File.Delete(UniversalBitmap.tmpFileHack);
            return image;
        }
#endif

        public UniversalBitmap(int width, int height)
        {
            this.Width = width;
            this.Height = height;
#if WINDOWS
            this.internalBitmap = new System.Drawing.Bitmap(width, height, System.Drawing.Imaging.PixelFormat.Format32bppArgb);
#elif OSX
            this.internalBitmap = new Cairo.ImageSurface(Cairo.Format.ARGB32, width, height);
#endif
        }

        public DrawingSession GetActiveDrawingSession()
        {
            if (this.activeDrawingSession == null) this.activeDrawingSession = new DrawingSession(this);
            return this.activeDrawingSession;
        }

        public BitLockSession GetActiveBitLockSession()
        {
            if (this.activeBitLockSession == null) this.activeBitLockSession = new BitLockSession(this);
            return this.activeBitLockSession;
        }

        public static bool IconSupported
        {
            get
            {
#if WINDOWS
                return true;
#elif OSX
                return false;
#endif
            }
        }

        public System.Drawing.Icon GenerateIcon()
        {
#if WINDOWS
            return System.Drawing.Icon.FromHandle(this.internalBitmap.GetHicon());
#elif OSX
            throw new System.NotImplementedException();
#endif
        }

        public class BitLockSession
        {
            private UniversalBitmap bmp;

#if WINDOWS
            private System.Drawing.Imaging.BitmapData internalSession;
#elif OSX
            private System.IntPtr ptr;
#endif

            public BitLockSession(UniversalBitmap bmp)
            {
                this.bmp = bmp;
#if WINDOWS
                this.internalSession = bmp.internalBitmap.LockBits(
                    new System.Drawing.Rectangle(0, 0, bmp.Width, bmp.Height),
                    System.Drawing.Imaging.ImageLockMode.ReadOnly,
                    System.Drawing.Imaging.PixelFormat.Format32bppArgb);
#elif OSX
                this.ptr = bmp.internalBitmap.DataPtr;
#endif
            }

            public System.IntPtr GetPtr()
            {
#if WINDOWS
                return this.internalSession.Scan0;
#elif OSX
                return this.ptr;
#endif
            }

            public void Free()
            {
#if WINDOWS
                this.bmp.internalBitmap.UnlockBits(this.internalSession);
#elif OSX
                // nothing to do, really.
#endif
            }
        }

        public class DrawingSession
        {
            private static int activeSessions = 0;

            private UniversalBitmap bmp;

#if WINDOWS
            private System.Drawing.Graphics internalSession;
#elif OSX
            private readonly Cairo.Context context;
#endif

            public DrawingSession(UniversalBitmap bmp)
            {
                activeSessions++;

                this.bmp = bmp;
#if WINDOWS
                this.internalSession = System.Drawing.Graphics.FromImage((System.Drawing.Bitmap)bmp.internalBitmap);
#elif OSX
                this.context = new Cairo.Context(bmp.internalBitmap);
#endif
            }

            public DrawingSession Draw(UniversalBitmap bmp, int targetX, int targetY, int sourceX, int sourceY, int width, int height)
            {
#if WINDOWS
                this.internalSession.DrawImage(
                    bmp.internalBitmap,
                    new System.Drawing.Rectangle(targetX, targetY, width, height),
                    new System.Drawing.Rectangle(sourceX, sourceY, width, height),
                    System.Drawing.GraphicsUnit.Pixel);
#elif OSX
                if (width != bmp.Width || height != bmp.Height)
                {
                    throw new System.NotImplementedException();
                }

                this.context.SetSource(bmp.internalBitmap, targetX, targetY);
                this.context.Paint();
#endif
                return this;
            }

            public void Flush()
            {
                activeSessions--;
#if WINDOWS
                this.internalSession.Flush();
                this.internalSession.Dispose();
                this.bmp.activeDrawingSession = null;
#elif OSX
                this.context.Dispose();
#endif
            }

            public static void VerifyCleaned()
            {
                if (activeSessions != 0)
                {
                    throw new System.Exception("");
                }
            }
        }
    }
}

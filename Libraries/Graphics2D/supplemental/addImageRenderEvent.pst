// There are 13 args. But not all are used. So don't pop them all.

/*
    valueStack[n + 0] -> Draw queue wrapper object.
        nativeData[0] -> event queue
        nativeData[1] -> event queue length
        nativeData[2] -> image queue
        nativeData[3] -> image queue length

    valueStack[n + 1] -> GrahpicsTexture instance

    valueStack[n + 2] -> BIT MASK

    valueStack[n + 3 to 12] -> Copy these directly to the event queue

    GraphicsTexture's nativeData:
        data[0] -> GraphicsTextureResource's native data

        floats:
        data[1] -> texture left
        data[2] -> texture top
        data[3] -> texture right
        data[4] -> texture bottom

        ints:
        data[5] -> pixel width
        data[6] -> pixel height

    GraphicsTextureResource's nativeData:
        data[0] -> bool: is GL based?
        data[1] -> bool: is texture loaded?
        data[2] -> int: GL texture ID
        data[3] -> image resource
        data[4] -> pixel width
        data[5] -> pixel height
*/
Value lib_graphics2d_addImageRenderEvent(VmContext vm, Array<Value> args) {
    double float1 = 0.0;
    int i = 0;
    int int1 = 0;
    int int2 = 0;
    int int3 = 0;
    Array<Array<object>> objArrayArray2 = null;
    ObjectInstance objInstance2 = null;
    Value value = null;
    Value arg2 = args[1];
    Value arg3 = args[2];
    Value arg4 = args[3];
    Value arg5 = args[4];
    Value arg6 = args[5];
    Value arg7 = args[6];
    Value arg8 = args[7];
    Value arg9 = args[8];
    Value arg10 = args[9];
    Value arg11 = args[10];
    ObjectInstance objInstance1 = (ObjectInstance) args[0].internalValue;
    Array<object> objArray1 = objInstance1.nativeData;

    // Get the event queue, expand it
    Array<int> eventQueue = (Array<int>) objArray1[0];
    int len = (int) objArray1[1];
    if (len >= eventQueue.Size()) {
        eventQueue = lib_graphics2d_expandEventQueueCapacity(eventQueue);
        objArray1[0] = eventQueue;
    }
    objArray1[1] = len + 16;

    // Do the same with the image queue. Image queue is not created by the native data int writer, so it may be null.
    Array<Array<object>> objArrayArray1 = (Array<Array<object>>) objArray1[2]; // image queue
    if (objArrayArray1 == null) {
        int1 = 0;
        objArrayArray1 = new Array<Array<object>>(0);
    } else {
        int1 = (int) objArray1[3];
    }
    if (int1 >= objArrayArray1.Size()) {
        objArrayArray2 = new Array<Array<object>>(((int1 * 2) + 16));
        for (i = 0; i < int1; i += 1) {
            objArrayArray2[i] = objArrayArray1[i];
        }
        objArrayArray1 = objArrayArray2;
        objArray1[2] = objArrayArray1;
    }
    objArray1[3] = int1 + 1;

    // Add the image object's nativeData array to the image queue
    objInstance2 = (ObjectInstance) args[1].internalValue;
    objArray1 = objInstance2.nativeData;
    objArrayArray1[int1] = objArray1;

    bool isValid = true;
    bool isNoop = false;

    // Bit mask
    int flag = (int) args[2].internalValue;
    eventQueue[len] = 6;
    eventQueue[len + 1] = flag;

    // rotation
    if ((flag & 4) != 0) {
        Value rotationValue = args[11];
        if (rotationValue.type == Types.FLOAT) float1 = (double) rotationValue.internalValue;
        else if (rotationValue.type == Types.INTEGER) float1 = 0.0 + (int) rotationValue.internalValue;
        else isValid = false;

        eventQueue[len | 10] = Core.Int(canonicalizeAngle(float1) * 1048576);
    }

    // alpha
    if (isValid && (flag & 8) != 0) {
        Value alphaValue = args[12];

        if (alphaValue.type == Types.INTEGER) i = (int) alphaValue.internalValue;
        else if (alphaValue.type == Types.FLOAT) i = Core.Int(0.5 + (double) alphaValue.internalValue);
        else isValid = false;

        if (i > 254) eventQueue[len | 1] = flag - 8; // unset the alpha flag if alpha is 255+
        else if (i < 0) isNoop = true;
        else eventQueue[len | 11] = i;
    }

    // copy all the numbers
    for (i = 0; i < 8; i += 1) {
        // just blindly copy the rest of the numbers rounding floats to ints
        value = args[3 + i];
        if (value.type == Types.INTEGER) {
            int2 = (int) value.internalValue;
        } else {
            if (value.type == Types.FLOAT) {
                float1 = ((double) value.internalValue);
                int2 = Core.Int((float1 + 0.5));
            } else {
                isValid = false;
                i = 9;
            }
        }

        eventQueue[len + 2 + i] = int2;
    }

    // stretching
    if ((flag & 2) != 0) {
        // target width
        int2 = eventQueue[len + 6];
        if (int2 < 0) isValid = false;
        else if (int2 == 0) isNoop = true;

        // target height
        int2 = eventQueue[len + 7];
        if (int2 < 0) isValid = false;
        else if (int2 == 0) isNoop = true;
    }

    // slicing
    if ((flag & 1) != 0) {
        int1 = (int) objArray1[5]; // image width
        int2 = eventQueue[len + 2]; // source x
        int3 = eventQueue[len + 4]; // desired width
        if (int2 < 0 || (int2 + int3) > int1 || int3 < 0) {
            isValid = false;
        }
        if (int3 == 0) isNoop = true;

        if (isValid) {
            int1 = (int) objArray1[6]; // image height
            int2 = eventQueue[len + 3]; // source y
            int3 = eventQueue[len + 5]; // desired height
            if (int2 < 0 || (int2 + int3) > int1 || int3 < 0) {
                isValid = false;
            }
            if (int3 == 0) isNoop = true;
        }
    }

    if (isValid) {
        if (isNoop) {
            // Operation doesn't achieve anything. Revert it from the queue.
            objArray1 = objInstance1.nativeData;
            objArray1[1] = -16 + (int) objArray1[1];
            objArray1[3] = -1 + (int) objArray1[3];
        }

        return VALUE_TRUE;
    }

    // TODO: roll back the event queue here as well so that invalid data doesn't
    // get passed to the renderer.
    return VALUE_FALSE;
}

Array<int> lib_graphics2d_expandEventQueueCapacity(Array<int> a) {
    int len = a.Length();
    Array<int> output = new Array<int>(len * 2 + 16);
    for (int i = 0; i < len; i += 1) {
        output[i] = a[i];
    }
    return output;
}

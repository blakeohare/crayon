import Base64;
import CrayonExporter;
import FileIO;
import FileIOTemp;
import Images;
import Json;
import Math;
import Resources;
import TextEncoding;
import Wax;

class IosExporter {

    field buildData;
    field resDb;
    field properties;
    field cbxBundle;
    field templates;
    field outputDir;
    field args;

    constructor(buildData, useTempDir, args) {
        this.buildData = buildData;
        this.cbxBundle = this.buildData.getCbxBundle();
        this.resDb = this.cbxBundle.getResourceDatabase();
        this.properties = this.buildData.getExportProperties();
        this.templates = new TemplateLoader();

        this.outputDir = useTempDir
            ? FileIOTemp.TempFiles.createDirectory(5 * 60) // temp dir exists for 5 minutes
            : this.properties.getOutputDirectory();
        this.args = args;
    }

    function getOrientation() {
        orientations = this.args.get('orientations') ?? [];
        up = false;
        down = false;
        left = false;
        right = false;

        for (raw : orientations) {
            switch (raw) {
                case 'portrait': up = true; break;
                case 'upsidedown': down = true; break;
                case 'landscape': left = true; right = true; break;
                case 'landscapeleft': left = true; break;
                case 'landscaperight': right = true; break;
                case 'all': return 'fullSensor';
                default: return null;
            }
        }

        vert = up && down;
        hor = left && right;
        anyVert = up || down;
        anyHor = left || right;

        if (!anyHor && !anyVert) return 'unspecified';

        if (!anyHor) {
            if (vert) return 'sensorPortrait';
            if (up) return 'portrait';
            return 'reversePortrait';
        }

        if (!anyVert) {
            if (hor) return 'sensorLandscape';
            if (left) return 'landscape';
            return 'reverseLandscape';
        }

        if (hor && vert) return 'fullSensor';

        return 'fullSensor'; // enabling both orientations in one direction but only allowing one orientation in the transverse direction isn't a valid supported option in android, at least at the moment and as far as I can tell.
    }

    function exportJsBaseProject() {

        response = WaxHub.getActiveHub().awaitSendRequest('ExportWebExtension', {
            'buildData': this.buildData._data,
            'extArgs': {
                'useTmpDir': true,
                'filePrefix': '/',
                'fullPage': true,
                'min': false,
            }
        });

        return response;
    }

    function export() {
        errors = [];

        projectId = this.buildData.getProjectId();

        title = this.args.get('title');
        if (title.length == 0) {
            errors.add("App title is blank.");
        }

        if (errors.length > 0) {
            return { "errors": errors };
        }

        this.templates
            .addReplacement('PROJECT_ID', projectId)
            .addReplacement('PROJECT_ID_LOWERCASE', projectId.lower())
            .addReplacement('PROJECT_TITLE', title);
            //.addReplacement('ANDROID_ORIENTATION', this.getOrientation());

        response = this.exportJsBaseProject();
        errors = response.get('errors') ?? [];
        if (errors.length > 0) {
            return response;
        }
        jsDir = response.get('outputDir');
        files = {};
        includeWorkspace = !FileIO.fileExists(this.canonicalizePath(this.outputDir + '/.idea/workspace.xml'));
        this.doExport(jsDir, files, includeWorkspace);
        FileData.writeToDisk(this.outputDir, files);
    }

    function canonicalizePath(path) {
        parts = path.split('/');
        out = [parts[0]];
        for (i = 1; i < parts.length; i++) {
            if (parts[i] != '') out.add(parts[i]);
        }
        return FileIO.pathJoin(out);
    }

    function doExport(jsProjDir, filesOut, includeWorkspace) {
        projectId = this.buildData.getProjectId();

        files = {};
        for (file : this.gatherFilePaths(jsProjDir)) {
            files[file] = true;
        }
        files['test_server.py'] = false;

        for (path : files.keys()) {
            if (files[path]) {
                absPath = this.canonicalizePath(jsProjDir + '/' + path);
                if (path.endsWith('.js') || path.endsWith('.txt') || path.endsWith('.html')) {
                    text = FileIO.fileReadText(absPath);
                    text = this.alterBaseWebFile(path, text);
                    file = FileData.createTextFile(text);
                } else {
                    bytes = FileIO.fileReadBytes(absPath);
                    file = FileData.createBinaryFileFromBytes(bytes);
                }
                filesOut['app/src/main/assets/' + path] = file;
            }
        }

        filesOut['app/src/main/assets/ios.js'] = FileData.createTextFile(this.templates.getText('app/src/main/assets/ios.js'));

        this.exportIcons(filesOut);
    }

    // TODO: this is directly from the Android exporter. Update this to the ios format.
    function exportIcons(filesOut) {

        // Export icons for each of the various DPI's by using the provided icons and figuring out what the best fit is, size-wise.

        icons = [];
        for (iconPath : this.properties.getIconPaths()) {
            icons.add(Bitmap.fromBytes(FileIO.fileReadBytes(iconPath)));
        }
        if (icons.length == 0) icons.add(Bitmap.fromResource('app/src/main/IcLauncherWeb.png'));

        largest = icons[0];
        smallest = icons[0];
        for (i = 1; i < icons.length; i++) {
            icon = icons[i];
            if (Math.max(icon.width, icon.height) > Math.max(largest.width, largest.height)) largest = icon;
            if (Math.max(icon.width, icon.height) < Math.max(smallest.width, smallest.height)) smallest = icon;
        }

        dimensions = {
            'Hdpi': 72,
            'Mdpi': 48,
            'Xhdpi': 96,
            'Xxhdpi': 144,
        };

        for (dim : dimensions.keys()) {
            size = dimensions[dim];
            icon = null;
            if (size > Math.max(largest.width, largest.height)) icon = largest;
            else if (size < Math.max(largest.width, largest.height)) icon = smallest;
            else {
                best = largest;
                // find the smallest icon that is larger than the given size
                for (candidate : icons) {
                    cSz = Math.max(candidate.width, candidate.height);
                    if (cSz >= size && cSz < Math.max(best.width, best.height)) {
                        best = candidate;
                    }
                }
                icon = best;
            }

            iconCopy = new Bitmap(size, size);
            if (icon.width == icon.height) {
                newWidth = size;
                newHeight = size;
            } else if (icon.width > icon.height) {
                newHeight = size * icon.height / icon.width;
                newWidth = size;
            } else {
                newWidth = size * icon.width / icon.height;
                newHeight = size;
            }
            iconCopy
                .edit()
                .drawImageStretched(icon, (size - newWidth) / 2, (size - newHeight) / 2, newWidth, newHeight)
                .finish();

            filesOut['app/src/main/res/drawable-' + dim.lower() + '/ic_launcher.png'] = FileData.createBinaryFileFromBytes(iconCopy.toBytes(ImageFormat.PNG));
        }
    }

    function getTextFile(path) {
        return FileData.createTextFile(this.templates.getText(path));
    }

    function gatherFilePaths(dir) {
        out = [];
        this.gatherFilePathsImpl(dir, '', out);
        return out;
    }

    function alterBaseWebFile(path, content) {
        switch (path) {
            case 'index.html': return this.modifyIndexHtml(content);
            default: return content;
        }
    }

    function modifyIndexHtml(code) {
        lines = code.split('\n');
        newLines = [];
        for (line : lines) {
            if (line.contains('favicon.ico')) continue;
            if (line.trim() == '</head>') {
                newLines.add(
                    "<script src=\"ios.js\"></script>",
                    "<style type=\"text/css\">",
                    "  body { margin:0px; background-color:#000; }",
                    "  #crayon_host {",
                    "    background-color:#000;",
                    "    text-align:left;",
                    "    width:100%;",
                    "    height:100%;",
                    "  }",
                    "</style>");
            }
            newLines.add(line);
        }

        code = newLines.join('\n');
        /*
        code = code.replace(
            '<script src="',
            '<script src="file:///android_asset/');
        */
        return code;
    }

    function gatherFilePathsImpl(dir, prefix, out) {
        for (file : FileIO.directoryList(this.canonicalizePath(dir))) {
            skip = false;
            switch (file.lower()) {
                case '.ds_store':
                case 'thumbs.db':
                case '.gitignore':
                    skip = true;
                    break;
            }

            if (skip) continue;

            absPath = dir + '/' + file;
            relPath = prefix + (prefix == '' ? '' : '/') + file;

            if (FileIO.directoryExists(this.canonicalizePath(absPath))) {
                this.gatherFilePathsImpl(absPath, relPath, out);
            } else {
                out.add(relPath);
            }
        }
    }
}

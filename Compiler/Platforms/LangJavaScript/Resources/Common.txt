C$common = 1;
C$common$textResources = {};
C$common$jsFilePrefix = ''; // overridden by resources.js if present.
C$common$programData = null;
C$common$resources = {};
C$common$binaryResources = {};
C$common$libraryFunctionLookups = {};

C$common$globalOptions = {};
C$common$globalOptions['fullscreen'] = false;

function main() {
	C$common$programData = createVm(C$bytecode, C$common$resourceManifest);
	vmEnableLibStackTrace(C$common$programData);
	C$handleVmResult(startVm(C$common$programData));
}

function C$runInterpreter(execId) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreter(vm, execId));
}

function C$runInterpreterWithFunctionPointer(fp, args) {
	var vm = C$common$programData;
	return C$handleVmResult(runInterpreterWithFunctionPointer(vm, fp, args));
}

let C$convertNativeArgToValue = value => {
	let globals = vmGetGlobals(C$common$programData);
	if (value === null || value === undefined) return buildNull(globals);
	if (value === true || value === false) return buildBoolean(globals, value);
	switch (typeof(value)) {
		case 'string': return buildString(globals, value);
		case 'number': return value % 1 === 0 ? buildInteger(globals, value) : buildFloat(globals, value);
		case 'object':
			if (Array.isArray(value)) {
				let arr = [];
				for (let item of value) {
					arr.push(C$convertNativeArgToValue(item));
				}
				return buildList(arr);
			}
			let keys = Object.keys(value);
			let values = keys.map(k => C$convertNativeArgToValue(value[k]));
			return buildStringDictionary(globals, keys, values);
		default: return buildNull(globals);
	}
};

function C$runInterpreterWithFunctionPointerNativeArgs(fp, args) {
	return C$runInterpreterWithFunctionPointer(fp, args.map(C$convertNativeArgToValue));
}

function C$handleVmResult(res) {
	var vm = C$common$programData;
	var status = getVmResultStatus(res);
	while (status == 5 || status == 6) { // REINVOKE || LOAD_ASSEMBLY
		if (status == 5) {
			var delayMillis = Math.floor(1000 * getVmReinvokeDelay(res));
			var execId = getVmResultExecId(res);
			window.setTimeout(function() { C$runInterpreter(execId); }, delayMillis);
			return;
		} else {
			var parts = getVmResultAssemblyInfo(res).split(',');
			var name = parts[0];
			var version = parts[1];
			var startupFunc = parts[2];
			C$loadAssembly(name, version, startupFunc);
		}
		res = runInterpreter(vm, getVmResultExecId(res))
		status = getVmResultStatus(res);
	}

	if (status == 1 || status == 2 || status == 3) return;

	throw "Unknown status";
}

C$loadAssembly = function(name, ver, startupFn) {
	if (startupFn.length > 0) {
		var fn = window[startupFn];
		if (fn !== undefined) {
			fn(C$common$programData, []);
		}
	}
};

C$common$readResourceText = function (path) {
	var v = C$common$getTextRes(path);
	return !v ? null : v;
};

C$common$alwaysTrue = function () { return true; };
C$common$alwaysFalse = function () { return false; };

C$common$addTextRes = function (path, value) {
	C$common$textResources[path] = value;
};

C$common$getTextRes = function (path) {
	return C$common$textResources[path];
};

C$common$addBinaryRes = function (path, value) {
	C$common$binaryResources[path] = value;
};

C$common$getBinaryResBase64 = function (path) {
	return C$common$binaryResources[path];
};

C$common$print = function (value) {
	console.log(value);
};

C$common$scrapeLibFuncNames = function(libname) {
	var prefix = 'lib_' + libname + '_function_';
	var functions = {};
	for (var key in window) {
		if (key.indexOf(prefix) === 0) {
			var name = key.substring(prefix.length, key.length + prefix.length);
			functions[name] = window[key];
		}
	}
	C$common$libraryFunctionLookups[libname] = functions;
};

C$common$getFunction = function(name) {
	var p = name.split(',');
	var check = p[p.length - 1];
	if (window[check] !== undefined) {
		return window[check];
	}
	return null;
};

LIB$datetime$utcTimeZone = {
	name: "utc",
	isLocal: false,
	observesDst: false
};

LIB$datetime$extractTimeZone = function(nullableTz) {
	if (nullableTz === null) return LIB$datetime$utcTimeZone;
	return nullableTz;
};

LIB$datetime$getDataForLocalTimeZone = function(strOut, intOut) {
	var name = Intl.DateTimeFormat().resolvedOptions().timeZone;
	strOut[0] = name;
	strOut[1] = name;
	intOut[0] = -1; // TODO: remove this
	var now = new Date();
	var janSeconds = new Date(now.getFullYear(), 1, 1, 0, 0, 0).getTime() / 1000;
	var junSeconds = new Date(now.getFullYear(), 6, 1, 0, 0, 0).getTime() / 1000;
	var janToJunHours = (junSeconds - janSeconds) / 3600;
	var dstOccurs = (janToJunHours % 24) != 0;
	intOut[1] = dstOccurs ? 1 : 0;
	return {
		name: name,
		isLocal: true,
		observesDst: dstOccurs
	};
};

LIB$datetime$unixToStructured = function(intOut, nullableTimeZone, unixTime) {
	var unixTimeInt = Math.floor(unixTime);
	var micros = Math.floor(1000000 * (unixTime - unixTimeInt));
	var millis = Math.floor(micros / 1000);
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	var d = new Date(Math.floor(unixTime * 1000));
	intOut[6] = millis;
	intOut[7] = micros;
	if (tz.isLocal) {
		intOut[0] = d.getFullYear();
		intOut[1] = d.getMonth() + 1;
		intOut[2] = d.getDate();
		intOut[3] = d.getHours();
		intOut[4] = d.getMinutes();
		intOut[5] = d.getSeconds();
		intOut[8] = d.getDay() + 1;
	} else {
		var p = d.toISOString().split('Z')[0].split('T');
		var pd = p[0].split('-');
		var pt = p[1].split('.')[0].split(':');
		
		intOut[0] = parseInt(pd[0]);
		intOut[1] = parseInt(pd[1]);
		intOut[2] = parseInt(pd[2]);
		intOut[3] = parseInt(pt[0]);
		intOut[4] = parseInt(pt[1]);
		intOut[5] = parseInt(pt[2]);
		intOut[8] = new Date(intOut[0], intOut[1] - 1, intOut[2], 12, 0, 0).getDay() + 1;
	}
	return true;
};

LIB$datetime$pad = function(n, length) {
	n = n + '';
	while (n.length < length) {
		n = '0' + n;
	}
	return n;
};
LIB$datetime$parseDate = function(intOut, nullableTimeZone, year, month, day, hour, minute, microseconds) {
	var tz = LIB$datetime$extractTimeZone(nullableTimeZone);
	intOut[2] = microseconds % 1000000;
	intOut[0] = 1;
	var seconds = Math.floor((microseconds - intOut[2]) / 1000000);
	if (tz.isLocal) {
		var d = new Date(year, month - 1, day, hour, minute, seconds);
		intOut[1] = Math.floor(d.getTime() / 1000);
	} else {
		intOut[1] = new Date([
			year, "-",
			LIB$datetime$pad(month, 2), "-",
			LIB$datetime$pad(day, 2), "T",
			LIB$datetime$pad(hour, 2), ":",
			LIB$datetime$pad(minute, 2), ":",
			LIB$datetime$pad(seconds, 2), "Z"].join('')).getTime();
	}
};

LIB$datetime$getUtcOffsetAt = function(tz, unixTime) {
	var d = new Date(Math.floor(unixTime * 1000));
	return -60 * d.getTimezoneOffset();
};

C$interop$getInteropObj = () => {
	if (!window.CrayonInterop) window.CrayonInterop = {};
	return window.CrayonInterop;
};

C$interop$invoke = (fnName, argsStr, cbValue) => {
	let fn = C$interop$getInteropObj()[fnName];
	if (!fn) return false;
	let args = JSON.parse(argsStr).args;
	setTimeout(() => {
		let result = fn.apply(null, args);
		if (cbValue !== null) {
			Promise.resolve(result).then(value => {
				let valueStr = JSON.stringify({ value });
				C$runInterpreterWithFunctionPointerNativeArgs(cbValue, [valueStr]);
			});
		}
	}, 0);
	return true;
};

C$interop$callbacksById = {};

C$interop$registerCallback = (funcName, useReturn, funcValue) => {
	let ci = C$interop$getInteropObj();
	if (!ci.INTERNAL_ID_ALLOC) ci.INTERNAL_ID_ALLOC = 0;
	ci[funcName] = function() {
		let args = [];
		for (let i = 0; i < arguments.length; ++i) {
			args.push(arguments[i]);
		}
		let argStr = JSON.stringify({ args });
		let id = 0;
		let resolve = null;
		let p = null;
		if (useReturn) {
			p = new Promise(res => {resolve = res; });
			id = ++ci.INTERNAL_ID_ALLOC;
			C$interop$callbacksById[id] = resolve;
		} else {
			p = Promise.resolve(null);
		}
		setTimeout(() => {
			C$runInterpreterWithFunctionPointerNativeArgs(funcValue, [id, argStr]);
		}, 0);
		
		return p;
	};
};

C$interop$callbackReturn = (id, valueStr) => {
	if (id === 0) return;
	let fn = C$interop$callbacksById[id];
	delete C$interop$callbacksById[id];
	let retVal = JSON.parse(valueStr).value;
	fn(retVal);
};

C$http$send = (cb, failCb, url, method, contentType, binaryContent, textContent, headersKvp, bytesObj, bytesObjNativeData) => {
	let req = new XMLHttpRequest();
	
	req.onload = (e, e2) => {
		let headers = [];
		let ct = '';
		for (let rawHeader of req.getAllResponseHeaders().trim().split('\r\n')) {
			let t = rawHeader.split(':', 2);
			let name = t[0].trim();
			let value = t.length > 1 ? t[1].trim() : '';
			headers.push(name);
			headers.push(value);
			if (name.toLowerCase() == 'content-type') ct = value;
		}
		
		req.response.arrayBuffer().then(buf => {
			let nd = [];
			let arr = new Uint8Array(buf);
			let bl = arr.length;
			for (let i = 0; i < bl; ++i) {
				nd.push(arr[i]);
			}
			bytesObjNativeData[0] = nd;
			
			let text = null;
			try {
				text = new TextDecoder().decode(arr);
			} catch (_) { }
			
			C$runInterpreterWithFunctionPointer(cb, [
				C$convertNativeArgToValue(req.status),
				C$convertNativeArgToValue(req.statusText),
				C$convertNativeArgToValue(ct),
				C$convertNativeArgToValue(headers),
				bytesObj,
				C$convertNativeArgToValue(text)
			]);
		});
	};
	
	req.onerror = (e1, e2) => {
		C$runInterpreterWithFunctionPointer(failCb, []);
	};
	
	req.open(method, url, true);
	req.responseType = 'blob';
	
	for (let i = 0; i < headersKvp.length; i += 2) {
		let n = headersKvp[i];
		let v = headersKvp[i + 1];
		switch (n.toLowerCase()) {
			// These are forbidden by the browser.
			case 'content-type':
			case 'content-length':
			case 'user-agent':
				break;
			default:
				req.setRequestHeader(n, v);
				break;
		}
	}
	
	if (textContent !== null) {
		req.send(textContent);
	} else if (binaryContent !== null) {
		req.send(Int8Array.from(binaryContent));
	} else {
		req.send(null);
	}
};

C$ImageUtil$fromBytes = (data, szOut, ndOut, cb) => {
	if (data.length < 2) return null;
	let isPng = data.substr(0, 2) == 'iV';
	let loader = new Image();
	loader.onload = () => {
		let cnv = document.createElement('canvas');
		let [w, h] = [loader.width, loader.height];
		cnv.width = w;
		cnv.height = h;
		let ctx = cnv.getContext('2d');
		ctx.drawImage(loader, 0, 0);
		ndOut[0] = {
			canvas: cnv,
			ctx,
			b64: data,
		};
		C$runInterpreterWithFunctionPointerNativeArgs(cb, [0, w, h]);
	};
	loader.onerror = () => {
		C$runInterpreterWithFunctionPointerNativeArgs(cb, [2, 0, 0]);
	};
	loader.src = ('data:image/' + (isPng ? 'png' : 'jpeg') + ';base64,') + data;
	return false;
};

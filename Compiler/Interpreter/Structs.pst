struct Code {
    Array<int> ops;
    Array<Array<int>> args;
    Array<string> stringArgs;
    Array<Dictionary<int, int>> integerSwitchesByPc;
    Array<Dictionary<string, int>> stringSwitchesByPc;
}

// TODO: based on the value of ARRAY_IS_LIST, conditionally include a struct value that
// only has the proper available methods. This will catch any accidentally omission
// of @ext_boolean("ARRAY_IS_LIST") checks.
struct ListImpl {
    int size;
    int capacity;
    Array<Value> array;
    List<Value> list;
}

// Dictionaries in Crayon can only have 3 types of keys: integers, strings, and objects
// Dictionaries can hold any of these, but only hold one type at a time
struct DictImpl {
    int size;
    int keyType;
    Dictionary<int, int> intToIndex;
    Dictionary<string, int> stringToIndex;
    List<Value> keys;
    List<Value> values;
}

struct VmMetadata {
    Array<string> identifiers;
    List<string> identifiersBuilder;
    Dictionary<string, int> invIdentifiers;
    Array<Value> literalTable;
    List<Value> literalTableBuilder;
    Array<Dictionary<int, int>> integerSwitchLookups;
    List<Dictionary<int, int>> integerSwitchLookupsBuilder;
    Array<Dictionary<string, int>> stringSwitchLookups;
    List<Dictionary<string, int>> stringSwitchLookupsBuilder;
    Array<ClassInfo> classTable;
    Array<FunctionInfo> functionTable;
    Dictionary<int, FunctionInfo> lambdaTable;
    Array<int> globalNameIdToPrimitiveMethodName;
    Dictionary<int, Func<Value, VmContext, Array<Value>>> cniFunctionsById;
    int lengthId;
    Array<int> primitiveMethodFunctionIdFallbackLookup;
    int userCodeStart;
    string projectId;
    Array<Array<int>> esfData;
    MagicNumbers magicNumbers;
    Dictionary<string, int> invFunctionNameLiterals;
    Dictionary<int, Dictionary<int, int>> classMemberLocalizerBuilder;
}

struct VmGlobals {
    Value valueNull;
    Value boolTrue;
    Value boolFalse;
    Value intZero;
    Value intOne;
    Value intNegativeOne;
    Value floatZero;
    Value floatOne;
    Value stringEmpty;
    Array<Value> positiveIntegers;
    Array<Value> negativeIntegers;
    Dictionary<string, Value> commonStrings;
}

struct SymbolData {
    Array<List<Token>> tokenData;
    Array<string> sourceCode;
    List<string> sourceCodeBuilder;
}

struct VmContext {
    Dictionary<int, ExecutionContext> executionContexts;
    int lastExecutionContextId;
    Code byteCode;
    SymbolData symbolData;
    VmMetadata metadata;
    int instanceCounter;
    bool initializationComplete;

    List<int> classStaticInitializationStack;
    Array<Value> funcArgs;

    ResourceDB resourceDatabase;

    List<Value> shutdownHandlers;

    VmEnvironment environment;

    VmGlobals globals;
    Value globalNull;
    Value globalTrue;
    Value globalFalse;
}

struct VmEnvironment {
    Array<string> commandLineArgs;
    bool showLibStack;
}

struct ExecutionContext {
    int id;
    StackFrame stackTop;
    int currentValueStackSize;
    int valueStackCapacity;
    Array<Value> valueStack;
    Array<Value> localsStack;
    Array<int> localsStackSet;
    int localsStackSetToken;
    int executionCounter;
    bool activeExceptionHandled;
    Value activeException;
    bool executionStateChange;
    int executionStateChangeCommand;
    Interrupt activeInterrupt;
}

struct Interrupt {
    int type;
    int exceptionType; // TODO: rename this to intArg
    string exceptionMessage; // TODO: rename this to stringArg
    double sleepDurationSeconds;
}

struct StackFrame {
    int pc;
    int localsStackSetToken; // if localsStackSet[i + offset] has this value, then that means localsStack[i + offset] is valid.
    int localsStackOffset; // offset local ID by this to get the value in localsStack
    int localsStackOffsetEnd; // ending offset of the locals stack
    StackFrame previous;
    bool returnValueUsed;
    Value objectContext;
    int valueStackPopSize; // size of the value stack when this frame is popped.
    int markClassAsInitialized;
    int depth; // stack depth for infinite recursion detection
    int postFinallyBehavior; // value defined in PostFinallyBehavior enum
    Value returnValueTempStorage; // return value when you return but still need to run a finally block
    Dictionary<int, ClosureValuePointer> closureVariables; // lazily initialized since most functions will not use this.
}

struct InterpreterResult {
    int status; // InterpreterResultStatus enum
    string errorMessage;
    double reinvokeDelay; // a delay (in seconds) before reinvoking (if the status is REINVOKE). Used by Core.sleep()
    int executionContextId; // the execution context ID that just ran
    bool isRootContext;
    string loadAssemblyInformation;
}

struct Token {
    int lineIndex;
    int colIndex;
    int fileId;
}

struct Value {
    int type;
    object internalValue;
}

struct SystemMethod {
    Value context;
    int id;
}

/*
    When a class is about to be referenced, static initialization state is checked.
    If it is 0, then check to see if the base class chain has any 0's and initialize the last class
    up the chain. Class intializations work like function invocations where the return PC points to the
    exact same spot where the intialization was triggered, so that the code continues to run normally
    despite the interrupt of the static constructor.

    When a class is initialized, a new Array<Value> is allocated with length of .memberCount.
    Then a loop runs through all member ID/indexes and checks the fieldInitializationCommand.
    If it's a literal, it copies the value directly from the fieldInitializationLiteral in the class metadata here.
    If it's a LIST or DICT, then it creates an empty instance of those.
    LIST or DICT is only used if the field is initialized to an _empty_ List or Dictionary. Otherwise NULL is used.
    If it's a SYSTEM_NULL the value of null (not a Value, but an actual native null) is applied to that slot. This
    indicates that the member is actually referencing a method. This is lazily populated at runtime if a function
    reference without invocation is ever made.

    All other fields are populated by the constructor by the default field value code which is injected into the
    constructor's byte code between the base constructor invocation and the body of the constructor.
*/
struct ClassInfo {
    int id;
    int nameId;
    int baseClassId; // or -1 if no base class
    int assemblyId;
    int staticInitializationState; // 0 - not initialized, 1 - in progress, 2 - done
    Array<Value> staticFields;
    int staticConstructorFunctionId;
    int constructorFunctionId;

    int memberCount; // total number of fields and methods, flattened.
    // The following lists contain data on all flattened fields and methods indexed by member ID.
    // These values are replicated in children classes where the child class' members appear at the end of the list.
    Array<int> functionIds; // function ID or -1
    Array<int> fieldInitializationCommand; // 0 - USE_LITERAL, 1 - LIST, 2 - DICT, 3 - SYSTEM NULL (reserved for method)
    Array<Value> fieldInitializationLiteral;
    Array<int> fieldAccessModifiers; // access modifiers by ID. 1 - PUBLIC, 2 - PRIVATE, 3 - INTERNAL, 4 - PROTECTED, 5 - INTERNAL_PROTECTED

    // TODO: It might actually be good to create two of these, one that's global ID to all member ID's, and another
    // for global ID to assignable member ID's. This would eliminate a couple of CPU cycles and also partially pave
    // the road for private/protected/public modifiers.
    Dictionary<int, int> globalIdToMemberId;

    Dictionary<int, int> localeScopedNameIdToMemberId;

    string fullyQualifiedName;
}

struct FunctionInfo {
    int id;
    int nameId;
    int pc;
    int minArgs;
    int maxArgs;
    int type; // 0 - function, 1 - method, 2 - static method, 3 - constructor, 4 - static constructor, 5 - lambda
    int associatedClassId;
    int localsSize;
    Array<int> pcOffsetsForOptionalArgs;
    string name;
    Array<int> closureIds;
}

// Used as the internalValue of a Value instance for Class definition types.
struct ClassValue {
    bool isInterface;
    int classId; // or interface ID (when that is eventually implemented)
}

struct ObjectInstance {
    int classId;
    int objectId;
    Array<Value> members;

    // system libraries can attach arbitrary values to objects, which can be operated on more efficiently than values, and
    // are inherently inaccessible by user code.
    Array<object> nativeData;

    // Same idea as nativeData, except this will be cast to a library-specific struct and will eventually replace all
    // usages of nativeData.
    object nativeObject;
}

struct FunctionPointer {
    int type; // Enum value: FunctionPointerType
    Value context;
    int classId;
    int functionId; // For lambdas, this is just the PC of the LAMBDA op.
    Dictionary<int, ClosureValuePointer> closureVariables;
}

struct ClosureValuePointer {
    Value value; // this value is null when the variable isn't set yet.
}

struct PlatformRelayObject {
    int type;
    int iarg1;
    int iarg2;
    int iarg3;
    double farg1;
    string sarg1;
}

struct HttpRequest {
    int statusCode;
    string status;
    Dictionary<string, Array<string>> headers;
    string body;
}

struct ResourceInfo {
    string userPath;
    string internalPath;
    bool isText;
    string type; // e.g. SND, IMG, IMGSH, etc. Don't convert this to an enum. Want this to be extensible.
    string manifestParam; // e.g. the image sheet ID, multiple values here must be encoded if extended.
}

struct ResourceDB {
    Dictionary<string, Array<string>> filesPerDirectory;
    Dictionary<string, ResourceInfo> fileInfo;

    // The list that is outputed by $$lib_resources_getResourceData()
    List<Value> dataList;
}

struct MagicNumbers {
    int coreExceptionClassId;
    int coreGenerateExceptionFunctionId;
    int totalLocaleCount;
}

struct LibRegObj {
    List<object> functionPointers;
    List<string> functionNames;
    List<int> argCounts;
}

namespace Core {

    @localized('en', 'CRAYON_VERSION')
    @localized('es', 'ESCRAYON_VERSION')
    @localized('jp', 'JPCRAYON_VERSION')
    const CRAYON_VERSION = "0.2.1";

    @localized('en', 'Type')
    @localized('es', 'ESType')
    @localized('jp', 'JPType')
    enum Type {
        NULL = 0,
        BOOLEAN = 1,
        INTEGER = 2,
        FLOAT = 3,
        STRING = 4,
        LIST = 5,
        DICTIONARY = 6,
        OBJECT = 7,
        FUNCTION = 8,
        CLASS = 9,
    }

    @localized('en', 'assert')
    @localized('es', 'ESassert')
    @localized('jp', 'JPassert')
    function assert(condition, message = null) {
        return $$$('assert', condition, message, true);
    }

    @localized('en', 'fail')
    @localized('es', 'ESfail')
    @localized('jp', 'JPfail')
    function fail(message) {
        return $$$('assert', false, message, false);
    }

    @localized('en', 'chr')
    @localized('es', 'ESchr')
    @localized('jp', 'JPchr')
    function chr(value) {
        return $$$('chr', value);
    }

    @localized('en', 'currentTime')
    @localized('es', 'EScurrentTime')
    @localized('jp', 'JPcurrentTime')
    function currentTime() {
        return $$$('currentTime');
    }

    @localized('en', 'ord')
    @localized('es', 'ESord')
    @localized('jp', 'JPord')
    function ord(value) {
        return $$$('ord', value);
    }

    @localized('en', 'parseFloat')
    @localized('es', 'ESparseFloat')
    @localized('jp', 'JPparseFloat')
    function parseFloat(value) {
        return $$$('parseFloat', value);
    }

    @localized('en', 'parseInt')
    @localized('es', 'ESparseInt')
    @localized('jp', 'JPparseInt')
    function parseInt(value) {
        return $$$('parseInt', value);
    }

    @localized('en', 'print')
    @localized('es', 'publicar')
    @localized('jp', 'JPprint')
    function print(value) {
        return $$$('print', value);
    }

    @localized('en', 'sleep')
    @localized('es', 'ESsleep')
    @localized('jp', 'JPsleep')
    function sleep(seconds) {
        Core.assert(
            $$$('typeis', seconds, Core.Type.INTEGER, Core.Type.FLOAT) &&
            seconds >= 0, "Invalid argument.");
        return $$$('sleep', seconds);
    }

    @localized('en', 'typeof')
    @localized('es', 'EStypeof')
    @localized('jp', 'JPtypeof')
    function typeof(value) {
        return $$$('typeof',value);
    }

    @localized('en', 'isString')
    @localized('es', 'ESisString')
    @localized('jp', 'JPisString')
    function isString(value) {
        return $$$('typeis', value, Core.Type.STRING);
    }

    @localized('en', 'isNumber')
    @localized('es', 'ESisNumber')
    @localized('jp', 'JPisNumber')
    function isNumber(value) {
        return $$$('typeis', value, Core.Type.INTEGER, Core.Type.FLOAT);
    }

    function _LIB_CORE_list_sort_by_key(fp, list) {
        if (list.length > 1) {
            $$$('sortList', list, _LIB_CORE_list_map(fp, list));
        }
    }

    function _LIB_CORE_list_map(fp, list) {
        output = [];
        for (t : list) {
            output.add(fp(t));
        }
        return output;
    }

    function _LIB_CORE_list_filter(fp, list) {
        output = [];
        for (t : list) {
            b = fp(t);
            if (!$$$('typeis', b, Core.Type.BOOLEAN)) {
                Core.fail("Filter function returned a non-boolean value.");
            }
            if (b) {
                output.add(t);
            }
        }
        return output;
    }

    @localized('en', 'getCurrentExecutionToken')
    @localized('es', 'ESgetCurrentExecutionToken')
    @localized('jp', 'JPgetCurrentExecutionToken')
    function getCurrentExecutionToken() {
        return $$$('execId');
    }

    @localized('en', 'getExecutionIterationCounter')
    @localized('es', 'ESgetExecutionIterationCounter')
    @localized('jp', 'JPgetExecutionIterationCounter')
    function getExecutionIterationCounter() {
        return $$$('execCounter');
    }

    @localized('en', 'getProjectId')
    @localized('es', 'ESgetProjectId')
    @localized('jp', 'JPgetProjectId')
    function getProjectId() {
        return $$$('projectId');
    }

    // Interanlly called by fp.invoke(args)
    function _LIB_CORE_invoke(fp, args) {
        // MAGIC ALERT: There is a special compiler hack that checks specifically for this line (based on parent
        // function name) and compiles this function invocation with a special flag to treat the args list as
        // individually passed arguments.
        return fp(args);
    }

    // A simple dummy object.
    // The VM supports attaching native data to any object instance, and so this generally serves as
    // the canonical object to use for that purpose.
    @localized('en', 'Object')
    @localized('es', 'ESObject')
    @localized('jp', 'JPObject')
    class Object { }

    function setTimedCallback(cb, seconds, args = null) {
        return Dispatcher._setCallback(cb, args, $$$('currentTime') + seconds, seconds, false);
    }

    function setRecurringCallback(cb, seconds, args = null) {
        return Dispatcher._setCallback(cb, args, $$$('currentTime') + seconds, seconds, true);
    }

    static class Dispatcher {

        // When a UI framework is run, it must set this object using registerDispatcherFramework()
        // This object will then be tasked with registering timed callbacks.
        static field _dispatcherFramework = null;

        // If a callback is set before a dispatcher framework is registered, hold on to the
        // callback and then queue them when one is finally registered.
        static field _queuedCallbacks = [];

        static function _queueNextRecurrence(cb, deadline, interval) {
            dfw = Dispatcher._dispatcherFramework;
            if (dfw == null) {
                Dispatcher._queuedCallbacks.add([cb, null, deadline, interval, true]);
            } else {
                dfw._setTimedCallback(deadline, () => {
                    cb();
                    deadline += interval;
                    t = $$$('currentTime');
                    if (t > deadline) deadline = t;

                    Dispatcher._queueNextRecurrence(cb, deadline, interval);
                });
            }
        }

        static field _conditionalCallbacks = {};

        static function queueConditionalCallback(cb) {
            refKey = new Core.Object();
            Dispatcher._conditionalCallbacks[refKey] = cb;
            return refKey;
        }

        static function conditionalCallbackCompleted(refKey) {
            cb = Dispatcher._conditionalCallbacks.get(refKey);
            if (cb == null) return;
            cb();
            Dispatcher._conditionalCallbacks.remove(refKey);
        }

        // If no dispatcher framework is registered, you can flush the callbacks
        // manually.
        static function flush() {

            if (Dispatcher._queuedCallbacks.length > 0) {
                now = $$$('currentTime');
                newQueue = [];
                for (qcb : Dispatcher._queuedCallbacks) {
                    if (now >= qcb[2]) {
                        qcb[0].invoke(qcb[1] ?? []);
                        if (qcb[4]) {
                            deadline = qcb[2] + qcb[3];
                            if (deadline < now) {
                                deadline = now + qcb[3];
                            }
                            qcb[2] = deadline;
                            newQueue.add(qcb);
                        }
                    } else {
                        newQueue.add(qcb);
                    }
                }
                Dispatcher._queuedCallbacks = newQueue;
            }

            if (Dispatcher._conditionalCallbacks.length > 0) {
                // gives a chance for async stuff to get a hold of the main thread.
                $$$('sleep', 0.001);
            }
        }

        static function _setCallback(cb, args, triggerTime, seconds, recurring) {
            if (args != null && args.length > 0) {
                fn = () => { cb.invoke(args); };
            } else {
                fn = cb;
            }
            dfw = Dispatcher._dispatcherFramework;
            if (dfw == null) {
                Dispatcher._queuedCallbacks.add([fn, null, triggerTime, seconds, recurring]);
            } else if (recurring) {
                Dispatcher._queueNextRecurrence(fn, triggerTime, seconds);
            } else {
                dfw._setTimedCallback(triggerTime, fn);
            }
        }

        // call with null to clear the dispatcher framework.
        static function registerDispatcherFramework(f) {
            Dispatcher._dispatcherFramework = f;
            if (f != null) {
                for (qcb : Dispatcher._queuedCallbacks) {
                    Dispatcher._setCallback.invoke(qcb);
                }
                Dispatcher._queuedCallbacks.clear();
            }
        }
    }
}

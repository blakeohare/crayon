import Nori;
import XML;

namespace NoriXml {
	function registerFactoryMethod(name, builderFp) {
		NoriXmlHelper.constructorLookup[name] = builderFp;
	}
	
	static class NoriXmlHelper {
		static field constructorLookup = null;
		
		static constructor() {
			NoriXmlHelper.constructorLookup = {
				'Canvas': NoriXml.instantiate_Canvas,
				'DockPanel': NoriXml.instantiate_DockPanel,
				'Grid': NoriXml.instantiate_Grid,
				'MenuBar': NoriXml.instantiate_MenuBar,
				'MenuItem': NoriXml.instantiate_MenuItem,
				'MenuSeparator': NoriXml.instantiate_MenuSeparator,
				'Rectangle': NoriXml.instantiate_Rectangle,
				'StackPanel': NoriXml.instantiate_StackPanel,
				'TextArea': NoriXml.instantiate_TextArea,
				'Window': NoriXml.instantiate_Window,
			};
		}
		
		static function instantiateByName(name) {
			fp = NoriXmlHelper.constructorLookup.get(name);
			if (fp == null) Core.fail("Could not instantiate element from XML: '" + name + "'");
			return fp();
		}
		
		static function elementDoesNotHaveAttribute(elementName, attributeName) {
			return Core.fail("'" + elementName + "' does not have an attribute named '" + attributeName + "'");
		}
		
		static function applyAttribute(element, elementName, attributeName, attributeValue) {
			if (!element is Nori.Element) {
				if (element is Nori.Window) {
					switch (attributeName) {
						case 'title': return element.setTitle(attributeValue);
						case 'width': return element.setWidth(NoriXmlHelper.getIntOrThrow(attributeName, attributeValue));
						case 'height': return element.setHeight(NoriXmlHelper.getIntOrThrow(attributeName, attributeValue));
						default: return NoriXmlHelper.elementDoesNotHaveAttribute(elementName, attributeName);
					}
				}
					
				if (element is Nori.MenuItem) {
					switch (attributeName) {
						case 'text': return element.setText(attributeValue);
						case 'shortcut': return;
						case 'checked': return;
						case 'checkbox': return;
						case 'token': return element.setCommandToken(attributeValue);
						default: return NoriXmlHelper.elementDoesNotHaveAttribute(elementName, attributeName);
					}
				}
			} else {
				nd = element.fauxNativeData;
				switch (attributeName) {
					case 'horizontalAlignment':
						switch (attributeValue) {
							case 'stretch': nd['align-x'] = Nori.Alignment.STRETCH; return;
							case 'left': nd['align-x'] = Nori.Alignment.LEADING; return;
							case 'right': nd['align-x'] = Nori.Alignment.TRAILING; return;
							case 'center': nd['align-x'] = Nori.Alignment.CENTER; return;
							default: return NoriXmlHelper.invalidEnum(attributeName, attributeValue);
						}
					case 'verticalAlignment':
						switch (attributeValue) {
							case 'stretch': nd['align-y'] = Nori.Alignment.STRETCH; return;
							case 'top': nd['align-y'] = Nori.Alignment.LEADING; return;
							case 'bottom': nd['align-y'] = Nori.Alignment.TRAILING; return;
							case 'center': nd['align-y'] = Nori.Alignment.CENTER; return;
							default: return NoriXmlHelper.invalidEnum(attributeName, attributeValue);
						}
					case 'width': nd['suggested-width'] = NoriXmlHelper.getIntOrThrow(attributeName, attributeValue); return;
					case 'height': nd['suggested-height'] = NoriXmlHelper.getIntOrThrow(attributeName, attributeValue); return;
					case 'color':
						color = NoriXmlHelper.getColorOrThrow(attributeName, attributeValue);
						element.setColor(color[0], color[1], color[2], color[3]);
						return;
					case 'dock':
						switch (attributeValue) {
							case 'top': direction = Nori.DockDirection.TOP; break;
							case 'bottom': direction = Nori.DockDirection.BOTTOM; break;
							case 'left': direction = Nori.DockDirection.LEFT; break;
							case 'right': direction = Nori.DockDirection.RIGHT; break;
							default: return NoriXmlHelper.invalidEnum(attributeName, attributeValue);
						}
						return DockPanel.setDirection(element, direction);
					case 'margin':
						margin = NoriXmlHelper.getIntTupleOrThrow(attributeName, attributeValue, 4);
						nd['margin-left'] = margin[0];
						nd['margin-top'] = margin[1];
						nd['margin-right'] = margin[2];
						nd['margin-bottom'] = margin[3];
						return;
						
					default: break;
				}
			}
			
			Core.fail("TODO: extensible properties.");
		}
		
		static function getColorOrThrow(name, value) {
			switch (value) {
				case 'red': return [255, 0, 0, 255];
				case 'green': return [0, 128, 0, 255];
				case 'blue': return [0, 0, 255, 255];
				case 'yellow': return [255, 255, 0, 255];
				case 'orange': return [255, 128, 0, 255];
				case 'purple': return [128, 0, 128, 255];
				case 'white': return [255, 255, 255, 255];
				case 'black': return [0, 0, 0, 255];
				case 'gray': return [128, 128, 128, 255];
				case 'brown': return [128, 64, 0, 255];
				case 'transparent': return [0, 0, 0, 0];
			}
			parts = value.split(',');
			for (i = 0; i < parts.length; ++i) {
				c = Core.parseInt(parts[i]);
				if (c == null || c < 0 || c > 255) Core.fail("Invalid color component value for " + name + ": " + parts[i]);
				parts[i] = c;
			}
			
			if (parts.length == 3) parts.add(255);
			if (parts.length != 4) Core.fail("Expected 3 or 4 color components for attribute " + name + ". Found '" + value + "' instead.");
			return parts;
		}
		
		static function getIntTupleOrThrow(name, value, length) {
			parts = value.split(',');
			if (parts.length == 1) {
				parts *= length;
			}
			if (parts.length != length) Core.fail("Expected 1 or " + length + " components for attribute '" + name + "'. Found " + parts.length + " instead.");
			for (i = 0; i < length; ++i) {
				v = Core.parseInt(parts[i]);
				if (v == null) Core.fail("Unexpected value for attribute '" + name + "': '" + parts[i] + "'");
				parts[i] = v;
			}
			return parts;
		}
		
		static function getIntOrThrow(name, value) {
			output = Core.parseInt(value);
			if (output == null) {
				Core.fail("The " + name + " attribute expects an integer. Found '" + value + "' instead.");
			}
			return output;
		}
		
		static function invalidEnum(name, value) {
			Core.fail("Unrecognized value for attribute " + name + ": '" + value + "'");
		}
	}
	
	function parse(xml) {
		uiTree = XML.parse(xml);
		return NoriXml.buildElement(uiTree, null);
	}
	
	function buildElement(xmlElement, parent) {
		
		name = xmlElement.name;
		element = NoriXmlHelper.instantiateByName(name);
		attributes = xmlElement.attributes;
		for (attribute : attributes.keys()) {
			value = attributes[attribute];
			NoriXmlHelper.applyAttribute(element, name, attribute, value);
		}
		
		if (xmlElement.children.length > 0) {
			children = [];
			for (child : xmlElement.children) {
				if (child.type == NodeType.ELEMENT) {
					children.add(buildElement(child, element));
				}
			}
			
			content = ''; // no-ops in the foreach loop if not set and doesn't require new allocation like an empty list.
			if (element is Nori.Window) {
				hasContent = false;
				hasMenu = false;
				for (child : children) {
					if (child is Nori.MenuBar) {
						Core.assert(!hasMenu, "Window may only have one MenuBar");
						hasMenu = true;
						element.setMenu(child);
					} else {
						Core.assert(!hasContent, "Window may only have one content element.");
						hasContent = true;
						element.setContent(child);
					}
				}
			} else {
				content = children;
			}
			
			for (child : content) {
				element.addChild(child);
			}
		}
		
		return element;
	}
}